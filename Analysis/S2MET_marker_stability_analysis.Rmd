---
title: "S2 MET Marker Stability Analysis"
output: html_notebook
bibliography: C:/Users/Jeff/Documents/Literature/library.bib
---

This notebook will outline the analysis of GWAS mapping procedures using the S2MET data.


## Introduction

Load packages and set directories

```{r setup}

library(tidyverse)
library(stringr)
library(readxl)
library(GGally)
library(IRanges)

# Project and other directories
source("C:/Users/Jeff/Google Drive/Barley Lab/Projects/S2MET_Mapping/source.R")

# Load the marker effect FW results
load(file.path(result_dir, "S2MET_pheno_mar_eff_fw_results.RData"))


```


## Results

Visualize the correlation across environments of marker effects

```{r mar.eff.cor}

# First set up two-way table of marker effects and environments
S2_MET_marker_eff_table <- S2_MET_marker_eff_pheno_fw %>% 
  map(~select(., trait, marker, environment, mar_effect) %>% 
        distinct() %>% 
        spread(environment, mar_effect) ) 

# Calculate the pairwise correlation of marker effects between environments
S2_MET_marker_eff_corr <- S2_MET_marker_eff_table %>%
  map(~group_by(., trait) %>% 
        do({
          df <- .
          select(df, -trait, -marker) %>% 
            cor() %>% 
            as.data.frame() %>% 
            rownames_to_column("environment1") %>% 
            gather(environment2, corr, -environment1) }) )

# Find the minimum and maximum correlation
S2_MET_marker_eff_corr %>% 
  map(~filter(., environment1 != environment2) %>% 
        summarize_at(vars(corr), funs(min, max, mean), na.rm = T) )

# Plot
S2_MET_marker_eff_corr %>% 
  list(., names(.)) %>% 
  pmap_df(~mutate(.x, population = .y)) %>%
  ggplot(aes(x = environment1, y = environment2, fill = corr)) + 
  geom_tile() +
  facet_grid(population ~ trait) +
  scale_fill_gradient2() +
  theme_bw() +
  theme(
    axis.text = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title = element_blank()
  )


```



Plot a genomic map of marker effect stability

First the slope coefficient

```{r mar.stability.b}

# What should be the significance level
alpha <- 0.01

# For each trait, calculate empirical thresholds for significance
S2_MET_marker_eff_pheno_fw_sig <- S2_MET_marker_eff_pheno_fw %>%
  map(~filter(., stability_term == "b") %>% 
        group_by(trait) %>% 
        mutate(estimate = scale(estimate),
               lower_perc = quantile(estimate, alpha / 2), 
               upper_perc = quantile(estimate, 1 - (alpha / 2))) %>%
        ungroup() )

# Plot the stability coefficients over genomic distance
mar_eff_fw_b_plots <- S2_MET_marker_eff_pheno_fw_sig %>% 
  map(~select(., trait, marker:cM_pos, stability_term:upper_perc) %>%
        filter(stability_term == "b") %>% 
        rename(Stability = estimate) %>% # Rename
        ggplot(aes(x = pos / 1000000, y = Stability, col = Stability)) + 
        geom_abline(slope = 0, intercept = 0) +
        # Threshold lines
        geom_hline(aes(yintercept = lower_perc), lty = 2) +
        geom_hline(aes(yintercept = upper_perc), lty = 2) +
        geom_point() + 
        facet_grid(trait ~ chrom, space = "free_x", scales = "free", switch = "x") +
        scale_color_gradient2() +
        ylab("Type II Stability Coefficient (Standard Deviations)") +
        xlab("Position (Mbp)") +
        theme_bw() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1),
              panel.spacing.x = unit(x = 0, units = "in"),
              panel.border = element_blank()))

# Create a plot for the TP + VP
g_mar_eff_fw_b_all <- mar_eff_fw_b_plots$pop_all

# Create a plot for the TP only
(g_mar_eff_fw_b_tp <- mar_eff_fw_b_plots$pop_tp +
    labs(title = "Marker Stability/Sensitivity Across the Genome",
         subtitle = "Large coefficients indicate highly sensitive markers, while low coefficients indicate highly stable markers.",
         caption = str_c("Dashed line denotes markers outside the 99% quantile range. Number of environment: ",
                         n_distinct(S2_MET_marker_eff_pheno_fw$pop_tp$environment), ".")))
    

# Save
save_file <- file.path(fig_dir, "marker_stability_typeII_tp_map.jpg")
ggsave(filename = save_file, plot = g_mar_eff_fw_b_tp, height = 7, width = 9, dpi = 1000)

```

Use the slope estimates and standard errors to perform some hypothesis testing

```{r t.test.stability}

## What happens if we test the marker slopes via a t-test?
markeff_pheno_fw_adj <- S2_MET_marker_eff_pheno_fw  %>%
  map(., ~filter(., stability_term == "b") %>%
        select(trait, marker:cM_pos, b_std_error:estimate) %>% 
        distinct() %>%
        group_by(trait) %>% 
        mutate(t_stat = estimate / b_std_error, 
               p_not_zero = 2 * pt(abs(t_stat), df, lower.tail = FALSE), 
               p_gt_zero = pt(t_stat, df, lower.tail = FALSE), 
               p_lt_zero = 1 - p_gt_zero) %>%
        # Correct for multiple testing
        mutate_at(vars(starts_with("p_")), funs(adj = p.adjust(., "fdr"))) %>%
        mutate_at(vars(contains("adj")), funs(neg_log = -log10(.))) )

# Combine the stability vs sensitivity p-values
# gtlt = greater than / less than
markeff_pheno_fw_adj_gtlt <- markeff_pheno_fw_adj %>% 
  map(~ mutate(., p_lt_zero_adj_neg_log = -1 * p_lt_zero_adj_neg_log) %>% 
        select(trait:pos, p_gt_zero_adj_neg_log, p_lt_zero_adj_neg_log) %>% 
        gather(test_type, neg_log_p, -trait:-pos) %>%
        mutate(neg_log10_fdr05 = if_else(test_type == "p_gt_zero_adj_neg_log", -log10(0.05), log10(0.05)),
               neg_log10_fdr10 = if_else(test_type == "p_gt_zero_adj_neg_log", -log10(0.10), log10(0.10))) )

# Plots for both gt and lt
g_mar_fw_negpos_plots <- markeff_pheno_fw_adj_gtlt %>%
  map(~mutate(., chrom = as.factor(chrom)) %>%
        ggplot(aes(x = pos / 1000000, y = neg_log_p, group = chrom, col = chrom)) + 
        geom_point(aes(shape = test_type)) + 
        geom_hline(aes(yintercept = neg_log10_fdr05, lty = "FDR 05%")) +
        geom_hline(aes(yintercept = neg_log10_fdr10, lty = "FDR 10%")) +
        facet_grid(trait ~ chrom, switch = "x", scales = "free", space = "free_x") +
        scale_color_manual(guide = FALSE, 
                           values = set_names(rep(c("black", "grey75"), length.out = 7), seq(1, 7))) +
        scale_linetype_discrete(guide = FALSE) +
        ylab("-log(p)") +
        xlab("Position (Mbp)") +
        labs(title = "Genomewide Test for Marker Stability/Sensitivity",
             subtitle = "") +
        theme_bw() +
        theme(
          panel.spacing.x = unit(x = 0, units = "in"),
          panel.border = element_blank(),
          axis.text.x = element_text(angle = 45, hjust = 1)
        ) )

# Plot for TP + VP
g_mar_fw_negpos_plots$pop_all

# Just TP
g_mar_fw_negpos_plots$pop_tp


## Plot just the test of the slope being different from zero
markeff_pheno_fw_adj_nz <- markeff_pheno_fw_adj %>% 
  map(~ mutate(., neg_log10_fdr05 = -log10(0.05),
               neg_log10_fdr10 = -log10(0.10)) )

g_mar_fw_nz_plots <- markeff_pheno_fw_adj_nz %>%
  map(~mutate(., chrom = as.factor(chrom)) %>%
        ggplot(aes(x = pos / 1000000, y = p_not_zero_adj_neg_log)) + 
        geom_point() + 
        geom_hline(aes(yintercept = neg_log10_fdr05, lty = "FDR 05%")) +
        geom_hline(aes(yintercept = neg_log10_fdr10, lty = "FDR 10%")) +
        facet_grid(trait ~ chrom, switch = "x", scales = "free", space = "free_x") +
        scale_color_manual(guide = FALSE, 
                           values = set_names(rep(c("black", "grey75"), length.out = 7), seq(1, 7))) +
        scale_linetype_discrete(guide = FALSE) +
        ylab("-log(p)") +
        xlab("Position (Mbp)") +
        labs(title = "Genomewide Assocation Analysis for Phenotypic Stability",
             caption = "n = 183 lines used to calculate stability coefficients and n = 175 lines used\nfor association analysis. The bold line indicates the genomewide FDR threshold at 5%;\nthe dashed line at 10%.") +
        theme_bw() +
        theme(
          panel.spacing.x = unit(x = 0, units = "in"),
          panel.border = element_blank(),
          axis.text.x = element_text(angle = 45, hjust = 1)
        ) )


# Plot for TP + VP
g_mar_fw_nz_plots$pop_all

# Just TP
g_mar_fw_nz_plots$pop_tp


```



Now the deviation coefficient

```{r mar.stability.delta}

mar_eff_fw_delta_plots <- S2_MET_marker_eff_pheno_fw %>% 
  map(~select(., trait, marker:cM_pos, stability_term:estimate) %>%
        filter(stability_term == "delta") %>% 
        ggplot(aes(x = pos / 1000000, y = estimate)) + 
        geom_point() + 
        facet_grid(trait ~ chrom, space = "free_x", scales = "free") +
        ylab("Type III Stability Coefficient") +
        xlab("Position (Mbp)") +
        theme_bw() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1)) )

# Create a plot for the TP + VP
g_mar_eff_fw_delta_all <- mar_eff_fw_delta_plots$pop_all

# Create a plot for the TP only
g_mar_eff_fw_delta_tp <- mar_eff_fw_delta_plots$pop_tp

```




Filter outliers and determine windows

We will continue only with the TP data and for the slope of the regression curve. We define stable marker outliers as those below the lower threshold and sensitive markers as those above the upper threshold



```{r mar.fw.outlier}
# Determine the number of stable or sensitive markers for each trait
mar_eff_fw_b_tp <- S2_MET_marker_eff_pheno_fw_sig$pop_tp %>% 
  select(trait, marker:cM_pos, estimate:upper_perc) %>% 
  mutate(outlier = case_when(estimate >= upper_perc ~ "sensitive", 
                             estimate <= lower_perc ~ "stable", 
                             TRUE ~ "not_outlier")) %>%
  distinct()

# Filter the outliers
mar_stability_outliers <- mar_eff_fw_b_tp %>%
  filter(outlier != "not_outlier")

# Summarize
mar_stability_outliers %>% 
  group_by(trait, chrom, outlier) %>% 
  summarize(n_outliers = n())




## For each trait, chromosome, and outlier type, create different windows from each
## outlier SNP to cluster other outlier SNPS

# Vector of window sizes (in bp)
wind_size_list <- c(50000, 100000, 500000, 1000000, 50000000)

mar_stability_outliers_window <- mar_stability_outliers %>% 
  split(list(.$trait, .$chrom, .$outlier)) %>% 
  .[map_dbl(., nrow) > 0] %>%
  list(., map(., function(df) {
    # Iterate over window sizes
    groups <- wind_size_list %>% 
      map(function(wind_size) {
        # Create an IRanges object
        df_iranges <- IRanges(start = df$pos - wind_size, end = df$pos + wind_size)
        
        # Reduce and find unique groups
        df_iranges %>% 
          reduce() %>% 
          findOverlaps(query = ., subject = df_iranges) %>% 
          queryHits() %>%
          str_c("chr", df$chrom, "_", .) })
    
    # Return a data.frame
    groups %>% 
      set_names(str_c("window_", wind_size_list)) %>% 
      as_data_frame() })) %>%
  pmap_df(~bind_cols(.x, .y))


```
