---
title: "S2 MET Marker Stability Analysis"
output: html_notebook
bibliography: C:/Users/Jeff/Documents/Literature/library.bib
---

This notebook will look at marker effect stability from marker effect estimates 
in each environment

## Introduction

Load packages and set directories

```{r setup}

library(tidyverse)
library(stringr)
library(readxl) 
library(GenomicRanges)
library(qvalue)
library(lme4qtl)
library(patchwork)
library(neyhart)

# Project and other directories
source("C:/Users/Jeff/Google Drive/Barley Lab/Projects/S2MET_Mapping/source.R")

# Load the stability results
load(file.path(result_dir, "S2MET_pheno_mean_fw_results.RData"))
# List the files containing marker effect by environment estimates
mxe_files <- list.files(result_dir, pattern = "marker_by_env", full.names = TRUE)

# Iterate over files and save in a list
mxe_list <- list()
for (file in mxe_files) {
  load(file)
  trait <- str_extract(string = file, "[A-Za-z]*.RData") %>% str_replace(pattern = ".RData", "")
  
  mxe_list[[trait]] <- marker_score_out
}

# Get the marker information
snp_info <- S2TP_imputed_multi_genos_hmp %>%
  select(marker = rs, chrom, pos, cM_pos)

# Filter the BLUEs to use
S2_MET_BLUEs_use <- S2_MET_BLUEs %>% 
  filter(line_name %in% c(tp_geno)) %>%
  droplevels()

M <- S2TP_imputed_multi_genos_mat[tp_geno,]


```




## Results

Manage the mxe data and convert to a tidy data.frame

```{r tidy.mxe}

# Tidy up
marker_by_environment <- mxe_list %>%
  map(~map_df(., ~list(., names(.)) %>% pmap_df(~mutate(.x, marker = .y)))) %>%
  list(., names(.)) %>%
  pmap_df(~mutate(.x, trait = .y)) %>%
  as_data_frame() %>%
  select(trait, marker, names(.))

# Rename
mxe_df <- marker_by_environment %>% 
  mutate(environment = str_extract(term, "[A-Z]{3}[0-9]{2}")) %>%
  select(trait, marker, environment, estimate)

# Combine with the environmental mean
mxe_df1 <- mxe_df %>%
  left_join(., distinct(S2_MET_pheno_mean_fw, trait, environment, h), 
            by = c("environment", "trait"))

# Calculate the marker effect stability
marker_effect_stab <- mxe_df1 %>%
  group_by(trait, marker) %>%
  do({
    df <- . 
    # Fit the model
    fit <- lm(estimate ~ h, df)
    data_frame(b = coef(fit)[2], 
               b_std_error = summary(fit)$coefficients[2,"Std. Error"],
               delta = mean(resid(fit)^2),
               df = df.residual(fit),
               fit = list(fit)) })
    


# Add the snp information
S2_MET_marker_mean_fw <- mxe_df1 %>% 
  full_join(., marker_effect_stab, by = c("trait", "marker")) %>% 
  left_join(., snp_info, by = "marker") %>% 
  select(marker, chrom:cM_pos, trait, environment, estimate, h:delta, df)

# Save the data
save_file <- file.path(result_dir, "S2MET_marker_mean_fw_results.RData")
save("S2_MET_marker_mean_fw", "marker_effect_stab", file = save_file)

```


Plot the distribution of stability estimates


```{r plot.dist}

## Transform
S2_MET_marker_mean_fw_trans <- S2_MET_marker_mean_fw %>% 
  distinct(marker, chrom, pos, trait, b, delta) %>%
  mutate(log_delta = log(delta), b = b + 1)


## Plot the stability terms individually, then combine
# First define a common list of ggplot modifiers
g_mod <- list(
  geom_density(aes(fill = "blue")),
  xlab("Estimate"),
  theme_bw() +
  theme(axis.title.y = element_blank()) )

# Just plot linear stability
g_marker_fw_dens_b <- S2_MET_marker_mean_fw_trans %>%
  ggplot(aes(x = b)) + 
  labs(title = "Linear Stability") +
  facet_wrap( ~ trait, ncol = 1) +
  scale_fill_brewer(palette = "Set2", guide = FALSE) +
  g_mod


# Just plot non-linear stability
g_marker_fw_dens_delta <- S2_MET_marker_mean_fw_trans %>%
  ggplot(aes(x = log_delta)) + 
  labs(title = "Non-Linear Stability") +
  scale_fill_brewer(palette = "Set2", guide = FALSE) +
  facet_wrap( ~ trait, ncol = 1, scales = "free_x") +
  g_mod

# Add the plots together
g_marker_fw_dist <- g_marker_fw_dens_b + g_marker_fw_dens_delta

save_file <- file.path(fig_dir, "marker_stability_estimate_distriubtions.jpg")
ggsave(filename = save_file, plot = g_marker_fw_dist, height = 5.6, width = 5, dpi = 500)



```


Plot the stability estimates across the genome

```{r map.stab}

# Make some name edits and tidy
S2_MET_marker_mean_fw_tidy <- S2_MET_marker_mean_fw_trans %>%
  gather(coef, estimate, b:log_delta) %>%
  filter(coef != "log_delta") %>%
  mutate(stab_type = if_else(coef == "b", "Linear", "Non-Linear"))

g_mar_stab <- S2_MET_marker_mean_fw_tidy %>%
  ggplot(aes(x = pos / 1000000, y = estimate)) + 
  geom_point() + 
  facet_grid(trait + stab_type ~ chrom, scales = "free", space = "free_x", switch = "x") +
  theme_manhattan()


# Calculate a p-value for stability and one for sensitivity
# Linear tests only
marker_stability_hyp_test <- S2_MET_marker_mean_fw %>% 
  distinct(marker, chrom, pos, trait, b, b_std_error, df) %>% 
  mutate(statistic = b / b_std_error, 
         p_value_stab = pt(q = statistic, df = df), 
         p_value_sens = 1 - p_value_stab) %>%
  select(marker:trait, starts_with("p_value")) %>%
  gather(test, p_value, starts_with("p_value")) %>%
  group_by(trait, test) %>%
  mutate(q_value = qvalue(p_value)$qvalue,
         neg_log_p = -log10(p_value),
         neg_log_q = -log10(q_value) )

# Plot

  


```




First group markers into those that are highly stable, highly sensitive, or neither using empirical thresholds

```{r grp.mars}

# Tidy up
S2_MET_marker_mean_fw_tidy <- S2_MET_marker_mean_fw_trans %>% 
  select(-delta) %>% 
  gather(coef, estimate, -marker:-trait)
  

# What should be the cutoff level?
alpha <- 0.05

# For each trait, calculate empirical thresholds for significance
S2_MET_marker_eff_pheno_fw_sig <- S2_MET_marker_mean_fw_tidy %>%
  filter(coef == "b") %>% 
  group_by(trait) %>% 
  # mutate(estimate = scale(estimate)) %>%
  mutate(lower_perc = quantile(estimate, alpha / 2), 
         upper_perc = quantile(estimate, 1 - (alpha / 2))) %>%
  ungroup() %>%
  mutate(significance = case_when(estimate >= upper_perc ~ "sensitive",
                                  estimate <= lower_perc ~ "stable",
                                  TRUE ~ "average"),
         marker_type = if_else(str_detect(marker, "^S"), "GBS", "BOPA"))

# Calculate a table of GBS markers and sensitive/stable/notsignificant
mar_stab_table <- S2_MET_marker_eff_pheno_fw_sig %>% 
  group_by(trait, marker_type, significance) %>% 
  summarize(n = n()) %>% 
  mutate(prop = n / sum(n))

mar_stab_table %>% 
  select(-n) %>% 
  spread(significance, prop)


# Plot the distributions of marker effect stabilities and show the empirical threholds
g_b_dist <- S2_MET_marker_eff_pheno_fw_sig %>% 
  ggplot(aes(x = estimate, fill = "red")) + 
  geom_density() + 
  geom_vline(aes(xintercept = upper_perc)) +
  geom_vline(aes(xintercept = lower_perc)) + 
  facet_wrap(~ trait, ncol = 1, scales = "free_x") + 
  scale_fill_discrete(guide = FALSE) + 
  theme_bw()

# Boxplots
S2_MET_marker_mean_fw_tidy %>% 
  mutate(coef = if_else(coef == "b", "linear", "non-linear")) %>% 
  ggplot(aes(x = trait, y = estimate)) + 
  geom_boxplot() +
  facet_wrap(~ coef, scales = "free_y") +
  theme_bw()

# Calculate the mean stability per group
S2_MET_marker_eff_pheno_fw_sig %>% 
  group_by(trait, significance) %>% 
  summarize(mean = mean(estimate)) %>% 
  spread(significance, mean)

```

Now use a t test to determine stable / sensitive markers. Use either a one-sided or two-sided t-test to determine stable/sensitive markers

```{r stab.t.test}

S2_MET_marker_mean_fw_tomodel <- S2_MET_marker_mean_fw %>% 
  distinct(marker, chrom, pos, trait, b, b_std_error, df)

# Calculate t-statistics and then calculate one-sided versus two-sided p-values
S2_MET_marker_mean_fw_hyptest <- S2_MET_marker_mean_fw_tomodel %>% 
  mutate(statistic = b / b_std_error, 
         le_zero_pvalue = pt(q = statistic, df = df, lower.tail = TRUE), 
         gt_zero_pvalue = 1 - le_zero_pvalue, 
         not_zero_pvalue = 2 * pt(q = abs(statistic), df = df, lower.tail = FALSE))

# Adjust the p-values
S2_MET_marker_mean_fw_hyptest_adj <- S2_MET_marker_mean_fw_hyptest %>% 
  group_by(trait) %>% 
  mutate_at(vars(contains("pvalue")), funs(padj = p.adjust(p = ., method = "bonf"))) %>% 
  select(-ends_with("pvalue")) %>% 
  gather(test, padj, ends_with("padj")) %>%
  mutate(neg_log_padj = -log10(padj))

# Plot
S2_MET_marker_mean_fw_hyptest_adj %>% 
  filter(test == "not_zero_pvalue_padj") %>% 
  ggplot(aes(x = pos / 1000000, y = neg_log_padj)) + 
  geom_point() + 
  facet_grid(trait + test ~ chrom, scales = "free") + 
  theme_manhattan()



```



Determine the proportion of GxE variance ($V_{GE}$) that is explained by sensitive/stable markers vs not signficant markers

The mixed-model looks like:

$$
y_{ij} = \mu + g_i + t_j + (g_st)_{ij} + (g_{ns}t)_{ij} + \epsilon_{ij},
$$

where $g_i \sim N(0, \mathbf{K}\sigma^2_g)$, $(g_st)_{ij} \sim N(0, \mathbf{K_s}\sigma^2_{g_st})$, and $(g_{ns}t)_{ij} \sim N(0, \mathbf{K_{ns}}\sigma^2_{g_{ns}t})$. $\mathbf{K}$ is the kinship matrix calculated using all markers, $\mathbf{K_s}$ is the kinship matrix calculated using only stable/sensitive markers, and $\mathbf{K_{ns}}$ is the kinship matrix calculated using only non-signficiant markers

```{r prop.gxe1}

# Load the results
load(file.path(result_dir, "S2MET_pheno_mar_fw_varcomp_GrainYield.RData"))

var_comp_prop <- var_comp_out$GrainYield %>% 
  bind_rows() %>%
  by_row(sum, .collate = "cols", .to = "tot_var") %>%
  mutate_at(vars(-tot_var), funs(prop = . / tot_var))
  
# Test if the observations come from the same distribution
var_comp_prop %>% 
  summarize(ks_test = ks.test(x = gt_s_prop, gt_ns_prop)$p.value)
  
# Plot density plots for each type of marker
var_comp_prop %>%
  select(gt_s_prop, gt_ns_prop) %>%
  gather(term, prop) %>%
  ggplot(aes(x = prop, fill = term)) +
  geom_density(alpha = 0.75) +
  theme_bw()

```




#### Gene Annotation

Look at gene annotation with relation to the different groups of SNPs. 
Determine the proportion of SNPs in genes, gene-proximal, or intergenic
Perhaps look at other annotations such as exons or transcripts, etc.


```{r snp.annotation}

## Load the barley annotation
ann_dir <- "C:/Users/Jeff/Google Drive/Barley Lab/Projects/Genomics/Annotation"
load(file.path(ann_dir, "barley_genomic_ranges.RData"))

# Conver the SNPs in this experiment to a GRanges object
snp_info <- S2TP_imputed_multi_genos_hmp %>%
  select(rs:cM_pos) %>%
  separate(alleles, c("ref", "alt"), "/") %>%
  mutate(chrom = str_c("chr", chrom, "H"))

snp_info_grange <- GRanges(seqnames = snp_info$chrom,
                           ranges = IRanges(snp_info$pos, snp_info$pos),
                           ref = snp_info$ref, alt = snp_info$alt,
                           cM_pos = snp_info$cM_pos, rs = snp_info$rs)


# Find the distance to the nearest gene for each SNP
# Convert to a data.frame and add the SNP info
snp_info_distance_to_gene <- distanceToNearest(x = snp_info_grange, subject = barley_grange_list$genes) %>%
  as.data.frame() %>%
  bind_cols(snp_info, .) %>%
  mutate(gene_id = barley_grange_list$genes[subjectHits]$gene_id) %>% # Add the gene id
  select(-queryHits, -subjectHits)

# Assign a cutoff for proximal
proximity_cutoff <- 10000

## Assign genic, proximal, or non-genic 
snp_info_distance_to_gene_ann <- snp_info_distance_to_gene %>%
  mutate(class = case_when(distance == 0 ~ "genic",
                           between(distance, 0, proximity_cutoff) ~ "proximal",
                           distance > proximity_cutoff ~ "non-genic",
                           TRUE ~ as.character(NA)),
         class = parse_factor(class, levels = c("genic", "proximal", "non-genic")),
         marker_type = if_else(str_detect(rs, "^[1-2]{2}"), "BOPA", "GBS")) %>%
  dplyr::rename(marker = rs)

# Find the proportion of SNPs that are in each group. This forms the null proportion
null_snp_prop <- snp_info_distance_to_gene_ann %>% 
  group_by(class) %>% 
  summarize(nSNP = n()) %>%
  mutate(prop = nSNP / sum(nSNP))

# Curiosity - is there a difference between GBS and BOPA snps?
# Yes - vast majority of BOPA markers are genic - derived from ESTs - this makes sense

# Now use the marker stability estimates to group SNPs
snp_info_distance_to_gene_ann1 <- snp_info_distance_to_gene_ann %>%
  full_join(., select(S2_MET_marker_eff_pheno_fw_sig, marker, trait, significance),
            by = "marker")

# Group by the marker stability classes and calculate proportions
# Then add the null proportion
marker_stability_snp_prop <- snp_info_distance_to_gene_ann1 %>% 
  group_by(trait, significance, class) %>% 
  summarize(nSNP = n()) %>% 
  mutate(prop = nSNP / sum(nSNP),
         significance_SNP = sum(nSNP)) %>%
  left_join(., select(null_snp_prop, class, null_prop = prop), by = "class")
  

# Table
marker_stability_snp_prop %>%
  select(-nSNP, -null_prop) %>% 
  spread(class, prop)

## Perform an binomial exact test
## H0: the proportion of SNPs in each significance group in each class is
## not different than the proportion across all SNPs
marker_stability_snp_prop_test <- marker_stability_snp_prop %>% 
  group_by(trait, significance, class) %>%
  mutate(binom_test = list({binom.test(x = nSNP, n = significance_SNP, p = null_prop)})) %>%
  ungroup() %>% 
  mutate(p_value = map_dbl(binom_test, "p.value"),
         p_ann = case_when(p_value <= 0.01 ~ "***",
                           p_value <= 0.05 ~ "**",
                           p_value <= 0.10 ~ "*",
                           TRUE ~ ""))


# Plot
g_snp_ann_prop <- marker_stability_snp_prop_test %>% 
  select(trait, class, prop = null_prop) %>% 
  distinct() %>% 
  mutate(significance = "null") %>% 
  bind_rows(marker_stability_snp_prop_test, .) %>% 
  mutate(significance = parse_factor(significance, levels = c("null", "average", "sensitive", "stable"))) %>%
  ggplot(aes(x = class, y = prop, fill = significance,  group = significance)) + 
  geom_col(position = "dodge") + 
  geom_text(aes(label = p_ann), position = position_dodge(0.9), hjust = -1, vjust = 0.5, angle = 90) + 
  scale_fill_manual(values = rev(umn_palette(n = 6)[-c(1:2)])) + # Add custom colors
  facet_grid(~ trait) + 
  theme_bw()

save_file <- file.path(fig_dir, "marker_stability_gene_annotation.jpg")
ggsave(filename = save_file, plot = g_snp_ann_prop, height = 5, width = 8)

```

