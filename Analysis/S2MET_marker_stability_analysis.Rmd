---
title: "S2 MET Marker Stability Analysis"
output: html_notebook
bibliography: C:/Users/Jeff/Documents/Literature/library.bib
---

This notebook will look at marker effect stability from marker effect estimates 
in each environment

## Introduction

Load packages and set directories

```{r setup}

library(tidyverse)
library(stringr)
library(readxl) 
library(GenomicRanges)
library(qvalue)
library(lme4qtl)
library(patchwork)
library(neyhart)

# Project and other directories
source("C:/Users/Jeff/Google Drive/Barley Lab/Projects/S2MET_Mapping/source.R")

# Load the stability results
load(file.path(result_dir, "S2MET_pheno_mean_fw_results.RData"))
# List the files containing marker effect by environment estimates
mxe_files <- list.files(result_dir, pattern = "marker_by_env", full.names = TRUE)

# Iterate over files and save in a list
mxe_list <- list()
for (file in mxe_files) {
  load(file)
  trait <- str_extract(string = file, "[A-Za-z]*.RData") %>% str_replace(pattern = ".RData", "")
  
  mxe_list[[trait]] <- marker_score_out
}

# Get the marker information
snp_info <- S2TP_imputed_multi_genos_hmp %>%
  select(marker = rs, chrom, pos, cM_pos)

# Filter the BLUEs to use
S2_MET_BLUEs_use <- S2_MET_BLUEs %>% 
  filter(line_name %in% c(tp_geno)) %>%
  droplevels()

M <- S2TP_imputed_multi_genos_mat[tp_geno,]


```




## Results

Manage the mxe data and convert to a tidy data.frame

```{r tidy.mxe}

# Tidy up
marker_by_environment <- mxe_list %>%
  map(~map_df(., ~list(., names(.)) %>% pmap_df(~mutate(.x, marker = .y)))) %>%
  list(., names(.)) %>%
  pmap_df(~mutate(.x, trait = .y)) %>%
  as_data_frame() %>%
  select(trait, marker, names(.))

# Rename
mxe_df <- marker_by_environment %>% 
  mutate(environment = str_extract(term, "[A-Z]{3}[0-9]{2}")) %>%
  select(trait, marker, environment, estimate)

# Combine with the environmental mean
mxe_df1 <- mxe_df %>%
  left_join(., distinct(S2_MET_pheno_mean_fw, trait, environment, h), 
            by = c("environment", "trait"))

# Calculate the marker effect stability
marker_effect_stab <- mxe_df1 %>%
  group_by(trait, marker) %>%
  do({
    df <- . 
    # Fit the model
    fit <- lm(estimate ~ h, df)
    data_frame(b = coef(fit)[2], 
               b_std_error = summary(fit)$coefficients[2,"Std. Error"],
               delta = mean(resid(fit)^2),
               df = df.residual(fit),
               fit = list(fit)) })
    


# Add the snp information
S2_MET_marker_mean_fw <- mxe_df1 %>% 
  full_join(., marker_effect_stab, by = c("trait", "marker")) %>% 
  left_join(., snp_info, by = "marker") %>% 
  select(marker, chrom:cM_pos, trait, environment, estimate, h:delta, df)

# Save the data
save_file <- file.path(result_dir, "S2MET_marker_mean_fw_results.RData")
save("S2_MET_marker_mean_fw", "marker_effect_stab", file = save_file)

```


Plot the distribution of stability estimates


```{r plot.dist}

## Transform
S2_MET_marker_mean_fw_trans <- S2_MET_marker_mean_fw %>% 
  distinct(marker, chrom, pos, trait, b, delta) %>%
  mutate(log_delta = log(delta), b = b + 1)


## Plot the stability terms individually, then combine
# First define a common list of ggplot modifiers
g_mod <- list(
  geom_density(aes(fill = "blue")),
  xlab("Estimate"),
  theme_bw() +
  theme(axis.title.y = element_blank()) )

# Just plot linear stability
g_marker_fw_dens_b <- S2_MET_marker_mean_fw_trans %>%
  ggplot(aes(x = b)) + 
  labs(title = "Linear Stability") +
  facet_wrap( ~ trait, ncol = 1) +
  scale_fill_brewer(palette = "Set2", guide = FALSE) +
  g_mod


# Just plot non-linear stability
g_marker_fw_dens_delta <- S2_MET_marker_mean_fw_trans %>%
  ggplot(aes(x = log_delta)) + 
  labs(title = "Non-Linear Stability") +
  scale_fill_brewer(palette = "Set2", guide = FALSE) +
  facet_wrap( ~ trait, ncol = 1, scales = "free_x") +
  g_mod

# Add the plots together
g_marker_fw_dist <- g_marker_fw_dens_b + g_marker_fw_dens_delta

save_file <- file.path(fig_dir, "marker_stability_estimate_distriubtions.jpg")
ggsave(filename = save_file, plot = g_marker_fw_dist, height = 5.6, width = 5, dpi = 500)



```


Plot the stability estimates across the genome

```{r map.stab}

# Make some name edits and tidy
S2_MET_marker_mean_fw_tidy <- S2_MET_marker_mean_fw_trans %>%
  gather(coef, estimate, b:log_delta) %>%
  filter(coef != "log_delta") %>%
  mutate(stab_type = if_else(coef == "b", "Linear", "Non-Linear"))

g_mar_stab <- S2_MET_marker_mean_fw_tidy %>%
  ggplot(aes(x = pos / 1000000, y = estimate)) + 
  geom_point() + 
  facet_grid(trait + stab_type ~ chrom, scales = "free", space = "free_x", switch = "x") +
  theme_manhattan()


# Calculate a p-value for stability and one for sensitivity
# Linear tests only
marker_stability_hyp_test <- S2_MET_marker_mean_fw %>% 
  distinct(marker, chrom, pos, trait, b, b_std_error, df) %>% 
  mutate(statistic = b / b_std_error, 
         p_value_stab = pt(q = statistic, df = df), 
         p_value_sens = 1 - p_value_stab) %>%
  select(marker:trait, starts_with("p_value")) %>%
  gather(test, p_value, starts_with("p_value")) %>%
  group_by(trait, test) %>%
  mutate(q_value = qvalue(p_value)$qvalue,
         neg_log_p = -log10(p_value),
         neg_log_q = -log10(q_value) )

# Plot

  


```




First group markers into those that are highly stable, highly sensitive, or neither

```{r grp.mars}

# Tidy up
S2_MET_marker_mean_fw_tidy <- S2_MET_marker_mean_fw_trans %>% 
  select(-delta) %>% 
  gather(coef, estimate, -marker:-trait)
  

# What should be the cutoff level?
alpha <- 0.05

# For each trait, calculate empirical thresholds for significance
S2_MET_marker_eff_pheno_fw_sig <- S2_MET_marker_mean_fw_tidy %>%
  filter(coef == "b") %>% 
  group_by(trait) %>% 
  # mutate(estimate = scale(estimate)) %>%
  mutate(lower_perc = quantile(estimate, alpha / 2), 
         upper_perc = quantile(estimate, 1 - (alpha / 2))) %>%
  ungroup() %>%
  mutate(significance = case_when(estimate >= upper_perc ~ "sensitive",
                                  estimate <= lower_perc ~ "stable",
                                  TRUE ~ "average"),
         marker_type = if_else(str_detect(marker, "^S"), "GBS", "BOPA"))

# Calculate a table of GBS markers and sensitive/stable/notsignificant
mar_stab_table <- S2_MET_marker_eff_pheno_fw_sig %>% 
  group_by(trait, marker_type, significance) %>% 
  summarize(n = n()) %>% 
  mutate(prop = n / sum(n))

mar_stab_table %>% 
  select(-n) %>% 
  spread(significance, prop)


# Plot the distributions of marker effect stabilities and show the empirical threholds
g_b_dist <- S2_MET_marker_eff_pheno_fw_sig %>% 
  ggplot(aes(x = estimate, fill = "red")) + 
  geom_density() + 
  geom_vline(aes(xintercept = upper_perc)) +
  geom_vline(aes(xintercept = lower_perc)) + 
  facet_wrap(~ trait, ncol = 1, scales = "free_x") + 
  scale_fill_discrete(guide = FALSE) + 
  theme_bw()

# Boxplots
S2_MET_marker_mean_fw_tidy %>% 
  mutate(coef = if_else(coef == "b", "linear", "non-linear")) %>% 
  ggplot(aes(x = trait, y = estimate)) + 
  geom_boxplot() +
  facet_wrap(~ coef, scales = "free_y") +
  theme_bw()

# Calculate the mean stability per group
S2_MET_marker_eff_pheno_fw_sig %>% 
  group_by(trait, significance) %>% 
  summarize(mean = mean(estimate)) %>% 
  spread(significance, mean)

```


Determine the proportion of GxE variance ($V_{GE}$) that is explained by sensitive/stable markers vs not signficant markers

The mixed-model looks like:

$$
y_{ij} = \mu + g_i + t_j + (g_st)_{ij} + (g_{ns}t)_{ij} + \epsilon_{ij},
$$

where $g_i \sim N(0, \mathbf{K}\sigma^2_g)$, $(g_st)_{ij} \sim N(0, \mathbf{K_s}\sigma^2_{g_st})$, and $(g_{ns}t)_{ij} \sim N(0, \mathbf{K_{ns}}\sigma^2_{g_{ns}t})$. $\mathbf{K}$ is the kinship matrix calculated using all markers, $\mathbf{K_s}$ is the kinship matrix calculated using only stable/sensitive markers, and $\mathbf{K_{ns}}$ is the kinship matrix calculated using only non-signficiant markers

```{r prop.gxe1}

# Load the results
load(file.path(result_dir, "S2MET_pheno_mar_fw_varcomp_GrainYield.RData"))

var_comp_prop <- var_comp_out$GrainYield %>% 
  bind_rows() %>%
  by_row(sum, .collate = "cols", .to = "tot_var") %>%
  mutate_at(vars(-tot_var), funs(prop = . / tot_var))
  
# Test if the observations come from the same distribution
var_comp_prop %>% 
  summarize(ks_test = ks.test(x = gt_s_prop, gt_ns_prop)$p.value)
  
# Plot density plots for each type of marker
var_comp_prop %>%
  select(gt_s_prop, gt_ns_prop) %>%
  gather(term, prop) %>%
  ggplot(aes(x = prop, fill = term)) +
  geom_density(alpha = 0.75) +
  theme_bw()

```


Examine MxE by looking at the variance of marker effects in each environment


```{r mxe}

## Use the marker effect FW regression output to examine the original variance of
## marker effects across environments
marker_effect_env_var <- S2_MET_marker_eff_pheno_fw %>% 
  select(trait, marker:pos, environment, mar_effect) %>% 
  distinct() %>%
  group_by(trait, marker) %>%
  mutate(mar_effect_var = var(mar_effect))

# Plot
g_mar_eff_var <- marker_effect_env_var %>% 
  select(trait:pos, mar_effect_var) %>% 
  distinct() %>% 
  ggplot(aes(x = pos, y = mar_effect_var)) + 
  geom_point() + 
  facet_grid(trait ~ chrom, scales = "free", space = "free_x")

## Use the permutation results to establish a 95% confidence interval
load(file.path(result_dir, "S2MET_pheno_mar_eff_by_env_perm.RData"))

# For each trait, interation, and marker, calculate the variance of marker effects
# across environments
marker_env_var_perm <- phenos_mxe_perm_parallel_out %>% 
  unlist(recursive = FALSE, use.names = FALSE) %>%
  map_df(~group_by(., trait, marker) %>%
          summarize(mar_effect_var = var(effect)) %>%
          ungroup() )

# Calculate a confidence interval
marker_env_var_perm_ci <- marker_env_var_perm %>% 
  group_by(trait, marker) %>% 
  summarize(ci_lower = quantile(mar_effect_var, probs = alpha / 2), 
            ci_upper = quantile(mar_effect_var, probs = 1 - (alpha / 2))) %>%
  ungroup()

# Merge with the original results
marker_effect_env_var_sig <- marker_effect_env_var %>% 
  select(trait:pos, mar_effect_var) %>% 
  distinct() %>% 
  full_join(., marker_env_var_perm_ci)

marker_effect_env_var_sig



```







Determine the proportion of genetic variance of phenotypic stability ($V_G$) that is explained by sensitive/stable markers

<!-- This may not work because there are no replications -->

<!-- ```{r prop.g.fw} -->

<!-- # Number of model fittings -->
<!-- n_iter <- 10 -->


<!-- ## Calculate relationship matrices -->
<!-- # Extract the traits -->
<!-- trts <- unique(S2_MET_marker_eff_pheno_fw_sig$trait) -->
<!-- # Create a results list -->
<!-- var_comp_list <- vector("list", length(trts)) %>% -->
<!--   set_names(trts) -->

<!-- # Iterate over the traits -->
<!-- for (tr in trts) { -->

<!--   # Extract the data to use -->
<!--   pheno_df <- S2_MET_pheno_fw %>%  -->
<!--     filter(trait == tr, stability_term == "b") %>% -->
<!--     select(line_name, estimate, b_std_error) %>%  -->
<!--     distinct() %>% -->
<!--     droplevels() -->

<!--   # Extract the significant markers -->
<!--   sig_mar_df <- S2_MET_marker_eff_pheno_fw_sig %>%  -->
<!--     filter(trait == tr, significance != "not_significant") -->
<!--   # Extract non-sig markers -->
<!--   non_sig_mar_df <- S2_MET_marker_eff_pheno_fw_sig %>%  -->
<!--     filter(trait == tr, significance == "not_significant") -->

<!--   ## Subset marker relationship matrices -->
<!--   sig_mar <- pull(sig_mar_df, marker) -->
<!--   M_s <- M[,sig_mar] -->
<!--   K_s <- A.mat(X = M_s, min.MAF = 0, max.missing = 1) -->

<!--   non_sig_mar <- pull(non_sig_mar_df, marker) -->
<!--   # Sample markers to construct Ks -->
<!--   non_sig_mar_sample <- replicate(n = n_iter, {sort(sample(non_sig_mar, size = length(sig_mar)))}, simplify = FALSE) -->
<!--   M_ns_list <- map(non_sig_mar_sample, ~M[,.]) -->
<!--   K_ns_list <- map(M_ns_list, ~A.mat(X = ., min.MAF = 0, max.missing = 1)) -->

<!--   ## Model frame/matrices -->
<!--   mf <- model.frame(estimate ~ line_name + b_std_error, pheno_df) -->

<!--   y <- model.response(mf) -->

<!--   # Weights -->
<!--   R <- solve(diag(mf$b_std_error^2)) -->

<!--   X <- model.matrix(~ 1, mf) -->

<!--   # Random effect of genotypic main effect -->
<!--   Z_g <- model.matrix(~ -1 + line_name, mf) %>% -->
<!--     `colnames<-`(., colnames(K_s)) -->

<!--   # Iterate over the list of K_ns matrices -->
<!--   var_comp_out <- K_ns_list %>% -->
<!--     map_df(~sommer::mmer(Y = y, X = X, Z = list(g_s = list(Z = Z_g, K = K_s), g_ns = list(Z = Z_g, K = .)), -->
<!--                          R = list(units = R), silent = T) %>% .$var.comp %>% map_df(unname)) -->

<!--   # Add the output to the list -->
<!--   var_comp_list[[tr]] <- parallel_out -->

<!-- } # Close the trait for loop -->




<!-- ``` -->








