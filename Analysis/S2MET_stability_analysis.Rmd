---
title: "S2MET Stability Analysis"
output: html_notebook
bibliography: C:/Users/Jeff/Documents/Literature/library.bib
---

This notebook will outline the stability analysis of the S2MET phenotype data


## Introduction

Load packages and set directories

```{r setup}

library(tidyverse)
library(readxl)
library(lme4)
library(broom)
library(stringr)
library(modelr)
# library(FW)
library(ggridges)
library(ggforce)
library(pbr)
library(qvalue)
library(cowplot)
library(patchwork)
library(boot)

# Project and other directories
source("C:/Users/Jeff/Google Drive/Barley Lab/Projects/S2MET_Mapping/source.R")

tp_geno <- tp_geno_multi

# Remove the environments in which the vp was only observed
S2_MET_BLUEs_use <- S2_MET_BLUEs %>%
  filter(line_name %in% tp_geno,
         trait != "TestWeight") %>%
  ungroup()

# Number of environments and entries
env <- pull(distinct(S2_MET_BLUEs_use, environment))
n_env <- n_distinct(env)
n_entries <- n_distinct(S2_MET_BLUEs_use$line_name)


# Load fw data
load(file.path(result_dir, "S2MET_pheno_mean_fw_results.RData"))
# Load the marker effect FW results
load(file.path(result_dir, "S2MET_pheno_mar_eff_fw_results.RData"))


```


### Finlay-Wilkinson Regression

Use the environment means to calculate the FW stability coefficient. The model for the regression coefficients looks like:

$$
y_{ij} = \mu + G_i + (1 + b_i)E_j + \epsilon_{ij},
$$

where $y_{ij}$ is the BLUE of the *i*th genotype in the *j*th environment, $\mu$ is the overall mean, $g_i$ is the effect of the *i*th genotype, $E_j$ is the random effect of the *j*th environment, and $b_i$ is the regression coefficient of the response on the mean of the *j*th environment, andx $\epsilon_{ij}$ is the random error.

To fit FW, we first fit a regular quantitative genetic model:

$$
y_{ij} = \mu + G_i + E_j + \epsilon_{ij}
$$

to obtain the environmental effects $E_j$. We then fit the following model for every genotype

$$
y_j = \mu + (1 + b)E_j + \epsilon_{ij}
$$




## Results

### Phenotypic Stability

Transformation

```{r fw.trans}

# Extract the unique stability coefficients
# Then add the breeding program information
S2_MET_pheno_fw_uniq <- S2_MET_pheno_mean_fw %>%
  select(trait, line_name, g, b, delta) %>% 
  distinct() %>%
  left_join(., subset(entry_list, Class == "S2TP", c(Line, Program)), 
            by = c("line_name" = "Line")) %>%
  rename(program = Program)

## Log transform the non-linear stability estimates
S2_MET_pheno_fw_uniq_trans <- S2_MET_pheno_fw_uniq %>%
  group_by(trait) %>% 
  mutate(log_delta = log(delta)) %>%
  # Tidy
  gather(term, value, b, delta, log_delta) %>% 
  filter(term != "delta")


```

#### Summary

Ranges and variances

```{r env.range}

# What is the range of environmental effects per trait?

# Combine df and mark the population
S2_MET_pheno_mean_fw %>%
  group_by(trait) %>% 
  summarize_at(vars(h), funs(min, max)) %>% 
  mutate(range = max - min)


# What is the quartile coefficient of dispersion for each measure of stability?
qcd <- function(x) {
  quants <- quantile(x = x, probs = c(0.50, 0.75))
  as.numeric(diff(quants) / sum(quants))
}

pheno_mean_fw_qcd <- S2_MET_pheno_fw_uniq_trans %>% 
  group_by(trait, term) %>%
  summarize(qcd = qcd(value))

# Plot
(g_qcd <- pheno_mean_fw_qcd %>% 
    ggplot(aes(x = trait, y = qcd, shape = term, color = term)) + 
    geom_point(size = 3) )


```



Plot the FW regression (regular version)

This is typical FW regression (i.e. using the phenotypic means)

```{r plot.fw.dist}

## Plot the stability terms individually, then combine
# First define a common list of ggplot modifiers
g_mod <- list(
  geom_density(aes(fill = "blue")),
  xlab("Estimate"),
  theme_bw() +
  theme(axis.title.y = element_blank()) )

# Just plot linear stability
g_pheno_fw_dens_b <- S2_MET_pheno_fw_uniq_trans %>%
  filter(term == "b") %>%
  ggplot(aes(x = value)) + 
  labs(title = "Linear Stability") +
  facet_wrap( ~ trait, ncol = 1) +
  scale_fill_brewer(palette = "Set2", guide = FALSE) +
  g_mod


# Just plot non-linear stability
g_pheno_fw_dens_delta <- S2_MET_pheno_fw_uniq_trans %>%
  filter(term == "log_delta") %>%
  ggplot(aes(x = value)) + 
  labs(title = "Non-Linear Stability") +
  scale_fill_brewer(palette = "Set2", guide = FALSE) +
  facet_wrap( ~ trait, ncol = 1, scales = "free_x") +
  g_mod

# Add the plots together
g_fw_dist <- g_pheno_fw_dens_b + g_pheno_fw_dens_delta

save_file <- file.path(fig_dir, "stability_estimate_distriubtions.jpg")
ggsave(filename = save_file, plot = g_fw_dist, height = 5.6, width = 5, dpi = 500)

```


There are some curiously high estimates of log_delta for HeadingDate. What is going on here?

```{r outlier.investigation}

# Filter the outliers
pheno_fw_outliers <- S2_MET_pheno_fw_uniq_trans %>% 
  filter(term == "log_delta", trait == "HeadingDate", value > 3)

# Extract the names of those lines
outlier_lines <- pheno_fw_outliers$line_name

# Look up the genotypic value
outlier_original_pheno_fw <- S2_MET_pheno_mean_fw %>% 
  filter(line_name %in% outlier_lines, trait == "HeadingDate") %>% 
  distinct(environment, line_name, trait, value, g, h, b, delta)

# Fit the regression models for these genotypes
outlier_lm <- outlier_original_pheno_fw %>% 
  group_by(line_name) %>% 
  do({
    df <- .
    fit <- lm(value ~ h, data = df)
    df %>% 
      add_residuals(model = fit) %>%
      mutate(stand_resid = resid / sd(resid)) })

# Plot the regression lines for these genotypes
outlier_original_pheno_fw %>% 
  ggplot(aes(x = h, y = value, group = line_name)) + 
  geom_point() + 
  geom_text(data = subset(outlier_lm, abs(stand_resid) >= 2.5), aes(label = environment)) +
  geom_smooth(method = "lm", se = FALSE) + 
  facet_wrap(~ line_name) +
  theme_bw()

``` 


Plot the stability estimates as lines against g_i vs h_j

```{r plot.fw}

# Add the program information to the results
S2_MET_pheno_mean_fw_toplot <- S2_MET_pheno_mean_fw %>% 
  select(trait, environment, line_name, value, g, h, b) %>% 
  left_join(., subset(entry_list, Class == "S2TP", c(Line, Program)), by = c("line_name" = "Line")) %>%
  rename(program = Program)

# Plot the normal FW analysis plot (genotype mean against environmental effects)
g_pheno_fw_b <- S2_MET_pheno_mean_fw_toplot %>%
  ggplot(aes(x = h, y = value, col = program, group = line_name)) + 
  geom_point() + 
  geom_abline(aes(slope = b, intercept = g, col = program), alpha = 0.15) +
  facet_wrap(~ trait, ncol = 1, scales = "free") +
  scale_color_discrete(drop = FALSE, guide = guide_legend(title = "Program", ncol = 1)) +
  ylab("Genotype Mean") +
  xlab("Environmental Effect") +
  labs(title = "Linear Phenotypic Stability") +
  # scale_color_brewer(palette = "Set2") +
  theme_bw() +
  theme(legend.position = "right",
        legend.background = element_rect(fill = "grey85", color = NA))

save_file <- file.path(fig_dir, "pheno_fw_b.jpg")
ggsave(filename = save_file, plot = g_pheno_fw_b, width = 5, height = 8)


## Subset genotypes to highlight different responses
pheno_fw_example <- S2_MET_pheno_mean_fw_toplot %>%
  distinct(trait, line_name, g, b) %>%
  group_by(trait) %>% 
  filter(b == min(b) | b == max(b) | abs(1 - b) == min(abs(1 - b)))

g_pheno_fw_b_example <- S2_MET_pheno_mean_fw_toplot %>%
  select(trait, environment, line_name, value, h) %>% 
  ggplot(aes(x = h, y = value)) + 
  geom_point() + 
  geom_abline(data = pheno_fw_example, aes(intercept = g, slope = b, col = line_name), lwd = 1) + 
  scale_color_discrete(guide = guide_legend(title = "Line Name", ncol = 1)) +
  facet_wrap(~ trait, ncol = 1, scales = "free") +
  ylab("Genotype Mean") +
  xlab("Environment Effect") +
  labs(title = "Example Genotype Responses") +
  theme_bw() +
  theme(legend.position = "right",
        legend.background = element_rect(fill = "grey85", color = NA),
        legend.text = element_text(size = 8),
        legend.title = element_text(size = 10))

save_file <- file.path(fig_dir, "pheno_fw_b_example.jpg")
ggsave(filename = save_file, plot = g_pheno_fw_b_example, width = 5, height = 8)



```



Plot the relationship between the genotypic effect and the sensitivity

First fit linear models to evaluate the relationship

```{r calc.corr}

# Calculate the correlation between genotype mean and the stability estimate
stability_mean_corr <- S2_MET_pheno_fw_uniq_trans %>%
  group_by(trait, term) %>% 
  # Bootstrap the correlation
  do(boot = {
    df <- .
    # Perform bootstrap
    boot_out <- df %>% 
      bootstrap(n = 1000) %>% 
      pull(strap) %>%
      map_dbl(~as.data.frame(.) %>% ungroup() %>% select(g, value) %>% cor(.) %>% .[1,2])
    
    # Summarize and export
    data.frame(cor = boot_out) %>% 
      summarize(boot_mean = mean(cor), se = sd(cor), 
                ci_lower = quantile(cor, 0.05 / 2), ci_upper = quantile(cor, 1 - (0.05 / 2))) }) %>%
  # Join with original data
  left_join(S2_MET_pheno_fw_uniq_trans, .) %>%
  # Calculate the base correlation and add a character annotation
  group_by(trait, term) %>% 
  mutate(corr = cor(g, value, use = "complete.obs"),
         corr = str_c("r = ", round(corr, 3))) %>% 
  unnest() %>%
  ungroup()


# Fit linear models
stability_mean_lm <- stability_mean_corr %>% 
  group_by(trait, term) %>%
  do(fit = lm(g ~ value, data = .))

# Tidy up
stability_mean_lm_tidy <- stability_mean_lm %>%
  ungroup() %>%
  mutate(tidy_fit = map(fit, tidy)) %>%
  unnest(tidy_fit) %>% 
  filter(term1 == "value")


# Remove the HeadingDate delta outliers
delta_outliers <- S2_MET_pheno_fw_uniq_trans %>% 
  filter(trait == "HeadingDate", term == "log_delta", value >= 3)

# Itersect and recalculate
stability_mean_corr_nooutlier <- setdiff(S2_MET_pheno_fw_uniq_trans, delta_outliers) %>%
  group_by(trait, term) %>% 
  mutate(corr = cor(g, value, use = "complete.obs"),
         corr = str_c("r = ", round(corr, 3)))

# Fit linear models
stability_mean_lm_nooutlier <- stability_mean_corr_nooutlier %>% 
  do(fit = lm(g ~ value, data = .))

# Tidy up
stability_mean_lm_nooutlier %>%
  ungroup() %>%
  mutate(tidy_fit = map(fit, tidy)) %>%
  unnest(tidy_fit) %>% 
  filter(term1 == "value")

```

Looks like significant regression slopes for the relationship between genotype mean and $b$ for GrainYield and PlantHeight, and between genotype mean and $\delta$ for HeadingDate and PlantHeight.

The relationship between genotype mean and $\delta$ is still significant after outlier removal


```{r plot.corr}

# Create a list of plot additions
g_add <- list(geom_point(),
              geom_smooth(method = "lm", se = FALSE, col = "black"),
              geom_text(aes(x = Inf, y = -Inf, label = corr, vjust = -1, hjust = 1.2), col = "black"),
              scale_color_discrete(name = "Program"),
              ylab("Estimate"),
              xlab("Genotype Mean"),
              theme_bw(),
              theme(legend.background = element_rect(fill = "grey85", color = NA)))

# Plot just the linear stability
g_linear_stability_and_mean <- stability_mean_corr %>%
  filter(term == "b") %>%
  ggplot(aes(x = g, y = value, col = program, group = FALSE)) +
  facet_wrap(~ trait, scales = "free_x", ncol = 1) +
  labs(title = "Linear Stability") +
  theme(legend.position = "right") +
  g_add
  
# Plot just the non-linear stability
g_nonlinear_stability_and_mean <- stability_mean_corr %>%
  filter(term == "log_delta") %>%
  ggplot(aes(x = g, y = value, col = program, group = FALSE)) +
  facet_wrap(~ trait, scales = "free", ncol = 1) +
  labs(title = "Non-Linear Stability" ) +
  theme(legend.position = "right") +
  g_add
  

# Plot grid
# Remove the legend from each plot object. Also remove the y axis title from the right-hand plot
g_plotgrid <- plot_grid(
  g_linear_stability_and_mean + theme(legend.position="none", axis.title.x = element_blank()),
  g_nonlinear_stability_and_mean + theme(legend.position="none", axis.title.x = element_blank()) + ylab(""),
  align = "h",
  labels = c("A", "B"))

# Extract the legend from one of the plots and add it back in
g_plotgrid1 <- plot_grid(
  g_plotgrid, get_legend(g_linear_stability_and_mean), rel_widths = c(2, 0.3)
)

# Add a common x-axis legend.
g_plotgrid2 <- ggdraw(add_sub(g_plotgrid1, "Genotype Mean", size = 12, hjust = 0.7))

save_file <- file.path(fig_dir, "pheno_fw_stability_mean.jpg")
ggsave(filename = save_file, plot = g_plotgrid2, width = 6, height = 6)


## Plot without the outliers
# Plot just the non-linear stability
g_nonlinear_stability_and_mean <- stability_mean_corr_nooutlier %>%
  filter(term == "log_delta") %>%
  ggplot(aes(x = g, y = value, col = program, group = FALSE)) +
  facet_wrap(~ trait, scales = "free", ncol = 1) +
  labs(title = "Non-Linear Stability" ) +
  theme(legend.position = "right") +
  g_add

# Plot grid
# Remove the legend from each plot object. Also remove the y axis title from the right-hand plot
g_plotgrid <- plot_grid(
  g_linear_stability_and_mean + theme(legend.position="none", axis.title.x = element_blank()),
  g_nonlinear_stability_and_mean + theme(legend.position="none", axis.title.x = element_blank()) + ylab(""),
  align = "h",
  labels = c("A", "B"))

# Extract the legend from one of the plots and add it back in
g_plotgrid1 <- plot_grid(
  g_plotgrid, get_legend(g_linear_stability_and_mean), rel_widths = c(2, 0.3)
)

# Add a common x-axis legend.
g_plotgrid2 <- ggdraw(add_sub(g_plotgrid1, "Genotype Mean", size = 12, hjust = 0.7))

save_file <- file.path(fig_dir, "pheno_fw_stability_mean_nooutliers.jpg")
ggsave(filename = save_file, plot = g_plotgrid2, width = 6, height = 6)


```


Heritability of the stability estimates

Estimate heritability via a mixed model with genotype effect modelled by the relationship matrix and residual genotype effect

```{r stab.herit}

library(rrBLUP)

# Extract the data for modelling
S2_MET_pheno_fw_tomodel <- S2_MET_pheno_mean_fw %>% 
  distinct(trait, line_name, b, b_std_error, delta) %>%
  mutate(log_delta = log(delta))
# 
# ## Estimate heritability by modeling the R matrix
# S2_MET_linear_fw_herit <- S2_MET_pheno_fw_tomodel %>%
#   group_by(trait) %>%
#   do({
#     # Extract data
#     df <- .
#     
#     # Use the square of the standard errors to model the weights
#     wts <- df$b_std_error^2
#     # lmer control
#     control <- lmerControl(check.nobs.vs.nlev = "ignore", check.nobs.vs.nRE = "ignore")
#     
#     # Fit
#     fit <- lmer(b ~ (1|line_name), data = df, control = control, weights = wts)
#     herit <- herit(object = fit, exp = "line_name / (line_name + Residual)")
#     
#     # Estimate heritability and return
#     data_frame(fit = list(fit), herit = herit)
#   })
    
## Estimate heritability by using the K matrix to model genotype effect (i.e. SNP heritability)
S2_MET_fw_herit <- S2_MET_pheno_fw_tomodel %>% 
  select(line_name, trait, b, log_delta) %>% 
  gather(stability_estimate, value, b, log_delta) %>%
  group_by(trait, stability_estimate) %>%
  do({
    # Extract data
    df <- .
    
    # Model frame and matrices
    mf <- model.frame(value ~ line_name, df)
    y <- model.response(mf)
    X <- model.matrix(~ 1, mf)
    Z_snp <- Z_g <- model.matrix(~ -1 + line_name, mf) # Two random effect matrices
    # Covariance matrices
    K_snp <- A.mat(X = S2TP_imputed_multi_genos_mat, min.MAF = 0, max.missing = 1)
    K_g <- diag(ncol(Z_g))
    
    # Single random effect model
    fit <- mixed.solve(y = y, Z = Z_snp, K = K_snp, X = X)
    # # Two random effect models
    # fit2 <- EMMREML::emmremlMultiKernel(y = y, X = X, Zlist = list(Z_snp, Z_g), Klist = list(K_snp, K_g))
    # fit2 <- sommer::mmer(Y = y, X = X, Z = list(snp = list(Z = Z_snp, K = K_snp), g = list(Z = Z_g, K = K_g)))
    
    # Heritability
    herit <- fit$Vu / (fit$Vu + fit$Ve)
    # herit <- fit2$Vu / (fit2$Vu + fit2$Ve)
    
    # Estimate heritability and return
    data.frame(herit = herit)
  })

S2_MET_fw_herit


```


How robust are our estimates of stability?

Use a resampling approach where 20, 40, 60, or 80% of the environments are used, then estimate the stability. Compare with the original estimation

```{r stab.robustness}

# Extract data to model
S2_MET_pheno_tomodel <- S2_MET_pheno_mean_fw %>% 
  distinct(environment, line_name, trait, value, std_error, h)

# Vector of proportion of environments
p_env <- seq(0.2, 0.8, by = 0.2)
# Number of bootstrap iterations
n_iter <- 100

# Iterate over the proportion of environments to sample
# Create bootstrapping replicates
S2_MET_pheno_samples <- p_env %>% 
  set_names(., .) %>%
  map(function(p) {
    # Create samples grouped by trait
    S2_MET_pheno_tomodel %>% 
      group_by(trait) %>% 
      do({
        trait_df <- .
        
        # Name of environments
        envs <- data_frame(environment = unique(trait_df$environment))

        # Sample environments n_iter times
        sample_envs <- rerun(n_iter, sample_frac(tbl = envs, size = p))
        
        # Map over the list and subset the trait data
        sample_trait_df <- sample_envs %>% 
          map(~left_join(., trait_df, by = "environment"))
        
        # Create and return a data.frame
        data_frame(iter = seq(n_iter), data = sample_trait_df) }) %>% ungroup()
  
    }) %>% list(., names(.)) %>% pmap_df(~mutate(.x, p = .y))

# Iterate over samples and calculate the stability coefficients
S2MET_pheno_sample_fw <- S2_MET_pheno_samples %>%
  unnest() %>%
  group_by(trait, p, iter, line_name) %>%
  select(-environment, -trait1, -std_error) %>%
  do({
    df <- .
    
    # Fit the linear model 
    fit <- lm(value ~ h, df)
    data.frame(b = coef(fit)[2], delta = mean(resid(fit)^2))
  }) 

# Ungroup
S2MET_pheno_sample_fw <- ungroup(S2MET_pheno_sample_fw)

# Save the results
save_file <- file.path(result_dir, "S2MET_pheno_fw_resampling.RData")
save("S2MET_pheno_sample_fw", file = save_file)

```





### Marker Effect Stability

Visualize the correlation across environments of marker effects

```{r mar.eff.cor}

# First set up two-way table of marker effects and environments
S2_MET_marker_eff_table <- S2_MET_marker_eff_pheno_fw %>% 
  select(., trait, marker, environment, mar_effect) %>% 
  distinct() %>% 
  spread(environment, mar_effect)

# Calculate the pairwise correlation of marker effects between environments
S2_MET_marker_eff_corr <- S2_MET_marker_eff_table %>%
  group_by(., trait) %>% 
  do({
    df <- .
    select(df, -trait, -marker) %>% 
      cor() %>% 
      as.data.frame() %>% 
      rownames_to_column("environment1") %>% 
      gather(environment2, corr, -environment1) })

# Find the minimum and maximum correlation
S2_MET_marker_eff_corr %>% 
  filter(., environment1 != environment2) %>% 
  summarize_at(vars(corr), funs(min, max, mean), na.rm = T)

# Plot
S2_MET_marker_eff_corr %>% 
  ggplot(aes(x = environment1, y = environment2, fill = corr)) + 
  geom_tile() +
  facet_grid(. ~ trait) +
  scale_fill_gradient2() +
  theme_bw() +
  theme(axis.text = element_text(size = 6),
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title = element_blank() )


```


Plot the distribution of linear and non-linear stability estimates for markers

```{r mar.stab.dist}

# Get the distinct observations of the stability measures
S2_MET_marker_eff_pheno_fw_uniq <- S2_MET_marker_eff_pheno_fw %>% 
  group_by(trait, marker) %>% 
  mutate(mean_marker_effect = mean(mar_effect)) %>% 
  ungroup() %>%
  select(trait, marker:pos, b_std_error, df, stability_term, estimate, mean_marker_effect) %>% 
  distinct()

# Plot histograms of the regression coefficients and MSEs
g_mar_fw_dens <- S2_MET_marker_eff_pheno_fw_uniq %>%
  ggplot(aes(x = estimate)) + 
  geom_density(aes(fill = "blue")) + 
  facet_wrap(trait ~ stability_term, ncol = 2, scales = "free") +
  xlab("Estimate") +
  labs(title = "Marker Effect Stability Measures") +
  scale_fill_brewer(palette = "Set2", guide = FALSE) +
  theme_bw() +
  theme(axis.title.y = element_blank())

save_file <- file.path(fig_dir, "marker_stability_estimate_distriubtions.jpg")
ggsave(filename = save_file, plot = g_mar_fw_dens, height = 6, width = 5)


# Calculate the mean effect per marker and plot that against the regression coefficient
g_mar_eff_stab <- S2_MET_marker_eff_pheno_fw_uniq %>% 
  filter(stability_term == "b") %>% 
  ggplot(aes(x = mean_marker_effect, y = estimate)) + 
  geom_point() + 
  facet_grid(~ trait, scales = "free_x") +
  theme_bw()

save_file <- file.path(fig_dir, "marker_mean_effect_and_stability.jpg")
ggsave(filename = save_file, plot = g_mar_eff_stab, height = 5, width = 7)


```



Plot a genomic map of marker effect stability


Determine outlier markers using a 2.5% empirical threshold

```{r mar.stability.b}

# What should be the significance level
alpha <- 0.05

# For each trait, calculate empirical thresholds for significance
S2_MET_marker_eff_pheno_fw_sig <- S2_MET_marker_eff_pheno_fw_uniq %>%
  filter(stability_term == "b") %>% 
  group_by(trait) %>% 
  # mutate(estimate = scale(estimate)) %>%
  mutate(lower_perc = quantile(estimate, alpha / 2), 
         upper_perc = quantile(estimate, 1 - (alpha / 2))) %>%
  ungroup()

# Plot the linear stability over genomic distance
g_mar_eff_fw_b <- S2_MET_marker_eff_pheno_fw_sig %>% 
  ggplot(aes(x = pos / 1000000, y = estimate)) + 
  geom_abline(slope = 0, intercept = 0) +
  # Threshold lines
  geom_hline(aes(yintercept = lower_perc), lty = 2) +
  geom_hline(aes(yintercept = upper_perc), lty = 2) +
  geom_point() + 
  facet_grid(trait ~ chrom, space = "free_x", scales = "free", switch = "x") +
  scale_color_gradient2() +
  ylab("Stability Coefficient") +
  xlab("Position (Mbp)") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.spacing.x = unit(x = 0, units = "in")) +
  labs(title = "Marker Linear Stability/Sensitivity")

# Save
save_file <- file.path(fig_dir, "marker_linear_stability.jpg")
ggsave(filename = save_file, plot = g_mar_eff_fw_b, height = 7, width = 9)


## Plot non-linear stability
# For each trait, calculate empirical thresholds for significance
S2_MET_marker_eff_pheno_fw_delta_sig <- S2_MET_marker_eff_pheno_fw_uniq %>%
  filter(stability_term == "delta") %>% 
  group_by(trait) %>% 
  # mutate(estimate = scale(estimate)) %>%
  mutate(upper_perc = quantile(estimate, 1 - (alpha / 2))) %>%
  ungroup()

g_mar_eff_fw_delta <- S2_MET_marker_eff_pheno_fw_delta_sig %>% 
  ggplot(aes(x = pos / 1000000, y = estimate)) + 
  geom_hline(aes(yintercept = upper_perc), lty = 2) +
  geom_point() + 
  facet_grid(trait ~ chrom, space = "free_x", scales = "free", switch = "x") +
  ylab("Stability Coefficient") +
  xlab("Position (Mbp)") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.spacing.x = unit(x = 0, units = "in"))  +
  labs(title = "Marker Non-Linear Stability/Sensitivity")

save_file <- file.path(fig_dir, "marker_nonlinear_stability.jpg")
ggsave(filename = save_file, plot = g_mar_eff_fw_delta, height = 7, width = 9)



```



Use the slope estimates and standard errors to perform some hypothesis testing

For the slope estimate, use a t-test to determine if the slope coefficient is significantly greater than 0 (i.e. plastic) or signficantly less than 0 (i.e. stable)

```{r t.test.stability}

## What happens if we test the marker slopes via a t-test?
mar_fw_linear_adj <- S2_MET_marker_eff_pheno_fw_uniq  %>%
  filter(stability_term == "b") %>%
  group_by(trait) %>%
  mutate(t_stat = estimate / b_std_error,
         p_not_zero = 2 * pt(abs(t_stat), df, lower.tail = FALSE),
         p_gt_zero = pt(t_stat, df, lower.tail = FALSE),
         p_lt_zero = 1 - p_gt_zero) %>%
  # Correct for multiple testing
  mutate_at(vars(starts_with("p_")), funs(qval = qvalue(.)$qvalue, local_fdr = qvalue(.)$lfdr)) %>%
  mutate_at(vars(contains("qval")), funs(neg_log = -log10(.)))

# Combine the stability vs sensitivity p-values
# gtlt = greater than / less than
mar_fw_linear_adj_gtlt <- mar_fw_linear_adj %>%
  # mutate(., p_lt_zero_qval_neg_log = -1 * p_lt_zero_qval_neg_log) %>%
  select(trait:pos, p_gt_zero_qval_neg_log, p_lt_zero_qval_neg_log, p_gt_zero_local_fdr, p_lt_zero_local_fdr) %>% 
  # Two sets of gather to tidy the dat
  gather(test_type, neg_log_q, p_gt_zero_qval_neg_log, p_lt_zero_qval_neg_log) %>% 
  gather(fdr_test, local_fdr, p_gt_zero_local_fdr, p_lt_zero_local_fdr) %>%
  filter((fdr_test == "p_gt_zero_local_fdr" & test_type == "p_gt_zero_qval_neg_log") |
         (fdr_test == "p_lt_zero_local_fdr" & test_type == "p_lt_zero_qval_neg_log")) %>%
  select(-fdr_test) %>%
  mutate(test_type = ifelse(test_type == "p_gt_zero_qval_neg_log", "plastic", "stable"),
         neg_log10_fdr05 = -log10(0.05),
         neg_log10_fdr10 = -log10(0.10))

# Filter out q-values for significance, then take the top q-value for each chromosome
top_qs <- mar_fw_linear_adj_gtlt %>%
  filter(neg_log_q >= neg_log10_fdr05) %>% 
  group_by(trait, test_type, chrom) %>% 
  top_n(1, neg_log_q) %>%
  mutate(local_fdr = str_c("fdr: ", round(local_fdr, 3)))

# Plots for both gt and lt
g_mar_fw_negpos_plots <- mar_fw_linear_adj_gtlt %>%
  # filter(trait == "HeadingDate") %>%
  mutate(., chrom = as.factor(chrom)) %>%
  ggplot(aes(x = pos / 1000000, y = neg_log_q)) +
  geom_point(aes(group = chrom, col = chrom)) + 
  # geom_text(data = top_qs, aes(x = pos / 1000000, y = neg_log_q, label = local_fdr), 
  #           size = 1.5, nudge_x = -150, check_overlap = T) +
  geom_hline(aes(yintercept = neg_log10_fdr05, lty = "FDR 05%")) +
  geom_hline(aes(yintercept = neg_log10_fdr10, lty = "FDR 10%")) +
  facet_grid(trait + test_type ~ chrom, switch = "x", scales = "free", space = "free_x") +
  scale_color_manual(guide = FALSE,
                     values = set_names(rep(c("black", "grey75"), length.out = 7), seq(1, 7))) +
  scale_shape_manual(values = c(16,1), labels = c("Sensitivity", "Stability"), name = "Test") +
  scale_linetype_discrete(guide = FALSE) +
  ylab("-log(q)") +
  xlab("Position (Mbp)") +
  labs(title = "Genomewide Test for Marker Linear Stability") +
  theme_bw() +
  theme(panel.spacing.x = unit(x = 0, units = "cm"),
        panel.spacing.y = unit(x = 0.5, units = "cm"),
        panel.border = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1))


save_file <- file.path(fig_dir, "marker_linear_stability_gtle_hyptest.jpg")
ggsave(filename = save_file, plot = g_mar_fw_negpos_plots, height = 9, width = 9)


## Plot just the test of the slope being different from zero
mar_fw_linear_adj_nz <- mar_fw_linear_adj %>%
  mutate(., neg_log10_fdr05 = -log10(0.05), neg_log10_fdr10 = -log10(0.10))

g_mar_fw_nz_plots <- mar_fw_linear_adj_nz %>%
  mutate(., chrom = as.factor(chrom)) %>%
  ggplot(aes(x = pos / 1000000, y = p_not_zero_qval_neg_log)) +
  geom_point() +
  geom_hline(aes(yintercept = neg_log10_fdr05, lty = "FDR 05%")) +
  geom_hline(aes(yintercept = neg_log10_fdr10, lty = "FDR 10%")) +
  facet_grid(trait ~ chrom, switch = "x", scales = "free", space = "free_x") +
  scale_color_manual(guide = FALSE,
                     values = set_names(rep(c("black", "grey75"), length.out = 7), seq(1, 7))) +
  scale_linetype_discrete(guide = FALSE) +
  ylab("-log(p)") +
  xlab("Position (Mbp)") +
  # labs(title = "Genomewide Assocation Analysis for Phenotypic Stability",
  #      caption = "n = 183 lines used to calculate stability coefficients and n = 175 lines used\nfor association analysis. The bold line indicates the genomewide FDR threshold at 5%;\nthe dashed line at 10%.") +
  theme_bw() +
  theme(panel.spacing.x = unit(x = 0, units = "cm"),
        panel.spacing.y = unit(x = 0.5, units = "cm"),
        panel.border = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1))

save_file <- file.path(fig_dir, "marker_linear_stability_nz_hyptest.jpg")
ggsave(filename = save_file, plot = g_mar_fw_nz_plots, height = 7, width = 9)



## Perform a significance test for non-linear stability




# Save the adjusted p-value results from the marker effect stability analysis
save_file <- file.path(result_dir, "S2MET_pheno_mar_eff_fw_results.RData")
save("S2_MET_marker_eff_pheno_fw", "mar_fw_linear_adj_gtlt", file = save_file)

```

Filter outliers and determine windows

We will continue only with the TP data and for the slope of the regression curve. We define stable marker outliers as those below the lower threshold and sensitive markers as those above the upper threshold



```{r mar.fw.outlier}
# Determine the number of stable or sensitive markers for each trait
mar_eff_fw_b_tp <- S2_MET_marker_eff_pheno_fw_sig$pop_tp %>% 
  select(trait, marker:cM_pos, estimate:upper_perc) %>% 
  mutate(outlier = case_when(estimate >= upper_perc ~ "sensitive", 
                             estimate <= lower_perc ~ "stable", 
                             TRUE ~ "not_outlier")) %>%
  distinct()

# Filter the outliers
mar_stability_outliers <- mar_eff_fw_b_tp %>%
  filter(outlier != "not_outlier")

# Summarize
mar_stability_outliers %>% 
  group_by(trait, chrom, outlier) %>% 
  summarize(n_outliers = n())




## For each trait, chromosome, and outlier type, create different windows from each
## outlier SNP to cluster other outlier SNPS

# Vector of window sizes (in bp)
wind_size_list <- c(50000, 100000, 500000, 1000000, 50000000)

mar_stability_outliers_window <- mar_stability_outliers %>% 
  split(list(.$trait, .$chrom, .$outlier)) %>% 
  .[map_dbl(., nrow) > 0] %>%
  list(., map(., function(df) {
    # Iterate over window sizes
    groups <- wind_size_list %>% 
      map(function(wind_size) {
        # Create an IRanges object
        df_iranges <- IRanges(start = df$pos - wind_size, end = df$pos + wind_size)
        
        # Reduce and find unique groups
        df_iranges %>% 
          reduce() %>% 
          findOverlaps(query = ., subject = df_iranges) %>% 
          queryHits() %>%
          str_c("chr", df$chrom, "_", .) })
    
    # Return a data.frame
    groups %>% 
      set_names(str_c("window_", wind_size_list)) %>% 
      as_data_frame() })) %>%
  pmap_df(~bind_cols(.x, .y))


```




