---
title: "S2 MET GWAS Analysis"
output: html_notebook
bibliography: C:/Users/Jeff/Documents/Literature/library.bib
---

This notebook will outline the analysis of GWAS mapping procedures using the S2MET data.

The GWAS will examine main effect QTL, QTLxE, and QTL influencing stability.


## Introduction

Load packages and set directories

```{r setup}

library(tidyverse)
library(purrrlyr)
library(readxl)
library(lme4)
library(rrBLUP)
library(broom)
library(GenomicRanges)
library(qvalue)
library(ggforce)
library(ggridges)
library(cowplot)
library(patchwork)
library(neyhart)

# Project and other directories
source("C:/Users/Jeff/Google Drive/Barley Lab/Projects/S2MET_Mapping/source.R")

tp_geno <- tp_geno_multi

load(file.path(geno_dir, "S2_genos_hmp.RData"))

# Filter environments for those in which the TP was observed
S2_MET_BLUEs_use <- S2_MET_BLUEs %>% 
  filter(line_name %in% tp_geno)

# Filter the genotype matrix for the TP only
# M <- s2_imputed_mat[tp_geno,]
M <- S2TP_imputed_multi_genos_mat[tp_geno,]

# Get the marker information
snp_info <- S2TP_imputed_multi_genos_hmp %>%
  select(marker = rs, chrom, pos, cM_pos) %>%
  # Correct the cM position for BOPA snps
  mutate(cM_pos = if_else(str_detect(marker, "^S"), cM_pos, cM_pos / 1000))

# Subset the entry list for the tp
tp_entry_list <- entry_list %>%
  filter(Line %in% tp_geno) %>%
  select(line_name = Line, program = Program)

alpha <- 0.05

```






## Methods

Convert the markers into a GRanges object, then align with the gene annotations



## Results

### Population Structure

First examine population structure within the germplasm

```{r pop.str}

# Calculate the kinship matrix
K <- A.mat(X = M, min.MAF = 0, max.missing = 1)

## Visualize pop structure
K_prcomp <- prcomp(K)

# Tidy, calculate lambda, then add program information
K_prcomp_df <- tidy(K_prcomp) %>%
  mutate(PC = str_c("PC", PC)) %>%
  dplyr::rename(line_name = row) %>%
  left_join(entry_list, by = c("line_name" = "Line"))

# Extract lambda and calculate variance explained
var_exp <- K_prcomp$sdev %>% 
  set_names(str_c("PC", seq_along(.))) %>%
  {. / sum(.)}

## Combine data.frame to plot
df_PC1_PC2 <- K_prcomp_df %>% 
  filter(PC %in% c("PC1", "PC2")) %>% 
  spread(PC, value) %>%
  mutate(x = "PC1", y = "PC2", var_expx = var_exp["PC1"], var_expy = var_exp["PC2"]) %>%
  dplyr::rename(xvalue = PC1, yvalue = PC2)

df_PC1_PC3 <- K_prcomp_df %>% 
  filter(PC %in% c("PC1", "PC3")) %>% 
  spread(PC, value) %>%
  mutate(x = "PC1", y = "PC3", var_expx = var_exp["PC1"], var_expy = var_exp["PC3"]) %>%
  dplyr::rename(xvalue = PC1, yvalue = PC3)

df_PC2_PC3 <- K_prcomp_df %>% 
  filter(PC %in% c("PC2", "PC3")) %>% 
  spread(PC, value) %>%
  mutate(x = "PC2", y = "PC3", var_expx = var_exp["PC3"], var_expy = var_exp["PC4"]) %>%
  dplyr::rename(xvalue = PC2, yvalue = PC3)

## Combine the data.frames
df_combined <- bind_rows(df_PC1_PC2, df_PC1_PC3, df_PC2_PC3)


# Plot
g_pop_str <- df_combined %>% 
  ggplot(aes(x = xvalue, y = yvalue, col = Program)) + 
  geom_point() + 
  facet_grid(y ~ x, switch = "both") +
  scale_color_discrete(guide = guide_legend(title = "Breeding\nProgram")) +
  theme_bw() + 
  theme(axis.title = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        legend.position = c(0.8, 0.8))

# Save this
save_file <- file.path(fig_dir, "population_structure.jpg")
ggsave(filename = save_file, plot = g_pop_str, width = 5, height = 5)

```




How is population structure correlated with the traits?

```{r mme.blues, eval=FALSE}

# Load the genotype means and FW regression results
load(file.path(result_dir, "S2MET_pheno_mean_fw_results.RData"))

# Transform the delta statistic to log-delta
S2_MET_pheno_mean_fw_trans <- S2_MET_pheno_mean_fw %>% 
  distinct(trait, line_name, g, b, delta) %>% 
  mutate(log_delta = log(delta)) %>%
  select(-delta)


# Combine the trait and PCs, duplicating the BLUEs to make summarizing smoother
trait_pop_str <- K_prcomp_df %>% 
  filter(PC %in% c("PC1", "PC2", "PC3")) %>% 
  select(line_name, program = Program, PC, eigenvalue = value) %>%
  left_join(., S2_MET_pheno_mean_fw_trans) %>%
  gather(measure, value, g:log_delta)


## Correlate the eigenvalues with the trait mean and stability, and calculate regression coefficients
## Use a bootstrap to estimate confidence interval
trait_pop_str_corr <- trait_pop_str %>% 
  group_by(trait, PC, measure) %>% 
  do(gws::boot_cor(x = .$value, y = .$eigenvalue, boot.reps = 10000)) %>%
  # Which ones are significant
  mutate(significant = !between(0, ci_lower, ci_upper),
         annotation = ifelse(significant, "*", ""))


# Add the correlations back to the data
trait_pop_str1 <- left_join(trait_pop_str, trait_pop_str_corr)

## Common plot modifier
g_mod <- list(
  geom_point(),
  geom_smooth(method = "lm", se = FALSE, color = "black"),
  geom_text(aes(x = Inf, y = -Inf, label = annotation), hjust = 1.5, vjust = 0.25, color = "black", size = 6),
  facet_grid(trait ~ PC, scales = "free"),
  scale_color_discrete(name = "Breeding\nProgram"),
  xlab("Eigenvalue"),
  theme_bw())


# Plot pop str vs mean
g_PC_v_mean <- trait_pop_str1 %>% 
  filter(measure == "g") %>%
  ggplot(aes(x = eigenvalue, y = value, col = program)) + 
  ylab("Genotypic Value") +
  g_mod

# Plot pop str vs linear stability
g_PC_v_b <- trait_pop_str1 %>% 
  filter(measure == "b") %>%
  ggplot(aes(x = eigenvalue, y = value, col = program)) + 
  ylab("Linear Stability") +
  g_mod

# Plot pop str vs nonlinear stability
g_PC_v_delta <- trait_pop_str1 %>%
  filter(measure == "log_delta") %>%
  ggplot(aes(x = eigenvalue, y = value, col = program)) + 
  ylab("Non-Linear Stability") +
  g_mod

# Save
save_file <- file.path(fig_dir, "population_structure_versus_mean.jpg")
ggsave(filename = save_file, plot = g_PC_v_mean, height = 4, width = 6)  

save_file <- file.path(fig_dir, "population_structure_versus_linear_stability.jpg")
ggsave(filename = save_file, plot = g_PC_v_b, height = 4, width = 6)  

save_file <- file.path(fig_dir, "population_structure_versus_nonlinear_stability.jpg")
ggsave(filename = save_file, plot = g_PC_v_delta, height = 4, width = 6)  

```


Several of the "traits" were significantly correlated with population structure (in the form of PC eigenvalues). This suggests that we are better-off using the G model instead of the QG model (as the eigenvalues will be confounded with the trait values).


### GWAS

The baseline model for GWAS is as follows:

$$
\mathbf{y = 1\beta + Wm + Zu + e}
$$

where $\mathbf{y}$ is the response vector, $\mathbf{1}$ is a vector of 1s for the grand mean, $\mathbf{\beta}$ is the grand mean, $\mathbf{Z}$ is the incidence matrix modeling the random genetic background effect, $\mathbf{g}$ is the vector of random genetic background effects, $\mathbf{W}$ is the SNP marker matrix, and $\mathbf{m}$ is the vector of fixed additive SNP effects. $\mathbf{g}$ is assumed to be distributed such that $\mathbf{g} \sim N(0, \mathbf{K} \sigma^2_g )$, where $\mathbf{K}$ models the population structure among genotypes.

I use population parameters previously determined [P3D; @Kang2010] to speed up the models without reducing detection power significantly. I also the `gwas()` function in my `pbr` package. Models included K and G [@Bernardo2013b; @Chen2016].


Load the results and adjust the p-values

```{r load.and.adj}

## Main effect QTL
load(file.path(result_dir, "S2MET_pheno_fw_mean_gwas_results.RData"))

# Convert to DF and filter for main effect assocations
gwas_pheno_mean_fw1 <- gwas_pheno_mean_fw %>% 
  map_df(~mutate(.$scores, model = .$metadata$model)) %>%
  filter(term == "main_effect") %>%
  separate(trait, c("trait", "coef"), sep = "_", extra = "merge")

## Adjust the p-values
gwas_pheno_mean_fw_adj <- gwas_pheno_mean_fw1 %>%
  group_by(., trait, coef, model) %>% 
  mutate(p_adj = p.adjust(p_value, method = "fdr"),
         q_value = qvalue(p = p_value)$qvalue,
         local_fdr = qvalue(p = p_value)$lfdr,
         neg_log10_fdr05 = -log10(0.05),
         neg_log10_fdr10 = -log10(0.10)) %>%
  mutate_at(vars(p_value, p_adj, q_value), funs(neg_log10 = -log10(.))) %>%
  ungroup()



# Load the genome annotation intersections
load(file.path(result_dir, "snp_genome_annotation.RData"))


```





#### Main Effect QTL

This model was used to detect associations between loci and the genotypic mean of each trait.

Load the data and plot results

```{r main.effect.qtl}

# Confidence interval level for the qq plot
alpha <- 0.05 

# Plot the density of the p-values
g_pvalue_density <- gwas_pheno_mean_fw_adj %>% 
  filter(coef == "g") %>%
  ggplot(aes(x = p_value, y = model, fill = model)) + 
  geom_density_ridges(alpha = 0.75, lwd = 1) + 
  facet_grid(~ trait) +
  xlim(c(0, 1)) +
  theme_bw()

## Quality control
## QQ plot
qq_gwas_geno_mean_adj <- gwas_pheno_mean_fw_adj %>% 
  filter(coef == "g") %>%
  arrange(trait, model, p_value) %>%
  group_by(trait, model) %>%
  mutate(p_exp = ppoints(n = n()), # Generate p values under null of no associations
         neg_log10_p_exp = -log10(p_exp), # Convert to -log10(p)
         # Add a confidence interval based on the beta distribution (assumes independence of tests)
         ci_lower = -log10(qbeta(p = (alpha / 2), shape1 = seq(n()), rev(seq(n())))),
         ci_upper = -log10(qbeta(p = 1 - (alpha / 2), shape1 = seq(n()), rev(seq(n()))))) %>%
  select(trait, model, marker, neg_log10_p_exp, p_value_neg_log10, ci_lower, ci_upper)

# Plot
g_qq <- qq_gwas_geno_mean_adj %>% 
  ggplot(aes(x = neg_log10_p_exp, y = p_value_neg_log10, col = model)) + 
  geom_ribbon(aes(x = neg_log10_p_exp, ymin = ci_upper, ymax = ci_lower), fill = "grey75", inherit.aes = FALSE) +
  geom_abline(slope = 1, intercept = 0) + 
  geom_point() + 
  facet_wrap(~ trait, ncol = 2) +
  scale_color_discrete(name = "Model") +
  labs(title = "QQ Plot") +
  ylab(expression(-log[10](italic(p)))) +
  xlab(expression(Expected~-log[10](italic(p)))) +
  theme_bw() +
  theme(legend.position = c(0.8, 0.2))


save_file <- file.path(fig_dir, "gwas_pheno_genotype_mean_qq.jpg")
ggsave(filename = save_file, plot = g_qq, width = 5, height = 5)


## Common plot layers for the manhattan plots
g_add <- list(geom_point(),
              geom_hline(aes(yintercept = neg_log10_fdr05, lty = "FDR 05%")),
              geom_hline(aes(yintercept = neg_log10_fdr10, lty = "FDR 10%")),
              scale_color_manual(values = set_names(rep(c("black", "grey75"), length.out = 7), seq(1, 7)),
                                 guide = FALSE),
              scale_linetype(guide = FALSE),
              ylab("-log(q)"),
              xlab("Position"),
              labs(title = "Genomwide Assocation Analysis for Genotype Mean"),
              theme_bw(),
              theme_manhattan())



## Manhattan plot
g_man <- gwas_pheno_mean_fw_adj %>%
  filter(coef == "g") %>%
  mutate(chrom = as.factor(chrom)) %>% 
  # ggplot(aes(x = pos / 1000000, y = neg_log10_p_adj, group = chrom, col = chrom)) + 
  ggplot(aes(x = pos / 1000000, y = q_value_neg_log10, group = chrom, col = chrom)) +
  facet_grid(trait + model ~ chrom, switch = "x", scales = "free", space = "free_x") +
  g_add

save_file <- file.path(fig_dir, "gwas_pheno_genotype_mean_manhattan.jpg")
ggsave(filename = save_file, plot = g_man, width = 9, height = 12)


## Only consider the G models
g_man_Gmodels <- gwas_pheno_mean_fw_adj %>%
  filter(coef == "g") %>%
  filter(model %in% c("G", "QG")) %>%
  mutate(chrom = as.factor(chrom)) %>%
  # ggplot(aes(x = pos / 1000000, y = neg_log10_p_adj, group = chrom, col = chrom)) + 
  ggplot(aes(x = pos / 1000000, y = q_value_neg_log10, group = chrom, col = chrom)) + 
  facet_grid(trait + model ~ chrom, switch = "x", scales = "free", space = "free_x") +
  g_add

save_file <- file.path(fig_dir, "gwas_pheno_genotype_mean_manhattan_Gmodels.jpg")
ggsave(filename = save_file, plot = g_man_Gmodels, width = 9, height = 10)


## Just the G model
g_man_Gmodel <- gwas_pheno_mean_fw_adj %>%
  filter(coef == "g", model == "G") %>%
  mutate(chrom = as.factor(chrom)) %>%
  # ggplot(aes(x = pos / 1000000, y = neg_log10_p_adj, group = chrom, col = chrom)) + 
  ggplot(aes(x = pos / 1000000, y = q_value_neg_log10, group = chrom, col = chrom)) + 
  facet_grid(trait ~ chrom, switch = "x", scales = "free", space = "free_x") +
  g_add

save_file <- file.path(fig_dir, "gwas_pheno_genotype_mean_manhattan_Gmodel.jpg")
ggsave(filename = save_file, plot = g_man_Gmodel, width = 9, height = 8)

```



#### Stability QTL

First we will map QTL for trait stability. The stability coefficients are first calculated using FW regression, and the coefficients are then used in the GWAS mixed model:


Load the data, adjust p-values, and plot

```{r stability.gwas}

# Confidence interval level
alpha <- 0.05 

## Quality control
## QQ plot
qq_gwas_pheno_stab_adj <- gwas_pheno_mean_fw_adj %>% 
  filter(coef != "g") %>%
  arrange(trait, coef, model, p_value) %>%
  group_by(trait, coef, model) %>%
  mutate(p_exp = ppoints(n = n()), # Generate p values under null of no associations
         neg_log10_p_exp = -log10(p_exp), # Convert to -log10(p)
         # Add a confidence interval based on the beta distribution (assumes independence of tests)
         ci_lower = -log10(qbeta(p = (alpha / 2), shape1 = seq(n()), rev(seq(n())))),
         ci_upper = -log10(qbeta(p = 1 - (alpha / 2), shape1 = seq(n()), rev(seq(n()))))) %>%
  select(trait, coef, model, marker, neg_log10_p_exp, p_value_neg_log10, ci_lower, ci_upper)

# Plot
g_qq <- qq_gwas_pheno_stab_adj %>% 
  ggplot(aes(x = neg_log10_p_exp, y = p_value_neg_log10, col = model)) + 
  geom_ribbon(aes(x = neg_log10_p_exp, ymin = ci_upper, ymax = ci_lower), fill = "grey75", inherit.aes = FALSE) +
  geom_abline(slope = 1, intercept = 0) + 
  geom_point() + 
  facet_grid(trait ~ coef) +
  scale_color_discrete(name = "Model") +
  labs(title = "QQ Plot") +
  ylab(expression(-log[10](italic(p)))) +
  xlab(expression(Expected~-log[10](italic(p)))) +
  theme_bw()

save_file <- file.path(fig_dir, "gwas_pheno_stability_qq.jpg")
ggsave(filename = save_file, plot = g_qq, width = 5, height = 5)


# Manhattan plot
# Common modifier
g_add <- list(geom_point(),
              geom_hline(aes(yintercept = neg_log10_fdr05, lty = "FDR 05%")),
              geom_hline(aes(yintercept = neg_log10_fdr10, lty = "FDR 10%")),
              scale_color_manual(values = set_names(rep(c("black", "grey75"), length.out = 7), seq(1, 7)),
                                 guide = FALSE),
              scale_linetype(guide = FALSE),
              ylab("-log(q)"),
              xlab("Position"),
              labs(title = "Genomwide Assocation Analysis for Phenotypic Stability"),
              theme_manhattan())


g_man_tp <- gwas_pheno_mean_fw_adj %>%
  filter(coef != "g") %>%
  mutate(chrom = as.factor(chrom)) %>% 
  # ggplot(aes(x = pos / 1000000, y = neg_log10_p_adj, group = chrom, col = chrom)) + 
  ggplot(aes(x = pos / 1000000, y = q_value_neg_log10, group = chrom, col = chrom)) +
  facet_grid(trait + coef + model ~ chrom, switch = "x", scales = "free", space = "free_x") +
  g_add

save_file <- file.path(fig_dir, "gwas_pheno_fw_manhattan.jpg")
ggsave(filename = save_file, plot = g_man_tp, width = 9, height = 12)


## Only consider "G" models
g_man_tp_Gmodels <- gwas_pheno_mean_fw_adj %>%
  filter(model %in% c("G", "QG"), coef != "g") %>%
  mutate(chrom = as.factor(chrom),
         coef = if_else(coef == "b", "Linear", "Non-Linear")) %>% 
  # ggplot(aes(x = pos / 1000000, y = neg_log10_p_adj, group = chrom, col = chrom)) + 
  ggplot(aes(x = pos / 1000000, y = q_value_neg_log10, group = chrom, col = chrom)) +
  facet_grid(trait + coef + model ~ chrom, switch = "x", scales = "free", space = "free_x") +
  g_add
  
save_file <- file.path(fig_dir, "gwas_pheno_fw_manhattan_Gmodels.jpg")
ggsave(filename = save_file, plot = g_man_tp_Gmodels, width = 9, height = 12)


## Only consider the G model
g_man_Gonly <- gwas_pheno_mean_fw_adj %>%
  filter(model == "G", coef != "g") %>%
  mutate(chrom = as.factor(chrom),
         coef = if_else(coef == "b", "Linear", "Non-Linear")) %>% 
  ggplot(aes(x = pos / 1000000, y = q_value_neg_log10, group = chrom, col = chrom)) + 
  facet_grid(trait + coef ~ chrom, switch = "x", scales = "free", space = "free_x") +
  g_add

save_file <- file.path(fig_dir, "gwas_pheno_fw_manhattan_Gonly.jpg")
ggsave(filename = save_file, plot = g_man_Gonly, width = 9, height = 8)

```

Use the results of the multi-locus mixed model to plot the new significant loci

```{r plot.mlmm}

# Find the trait-markers that are not in the 'gwas_mlmm_Gmodel' df
gwas_pheno_mean_fw_adj_nonsig <- gwas_pheno_mean_fw_adj %>% 
  filter(model == "G") %>% 
  select(marker, trait, coef) %>% 
  dplyr::setdiff(., select(ungroup(gwas_mlmm_Gmodel), marker, trait, coef)) %>%
  left_join(., filter(gwas_pheno_mean_fw_adj, model == "G")) %>%
  mutate(q_value_neg_log10 = 0) %>% 
  select(trait, coef, marker, chrom, pos, estimate, p_value, q_value, q_value_neg_log10) %>% 
  unnest() %>% 
  dplyr::rename(alpha = estimate)

# Calculate the neg-log q values for the 'gwas_mlmm_Gmodel' df
gwas_mlmm_adj <- gwas_mlmm_Gmodel %>% 
  ungroup() %>%
  mutate(q_value_neg_log10 = -log10(q_value))

# Combine with the significant markers
gwas_pheno_mean_fw_adj_mlmm <- bind_rows(gwas_pheno_mean_fw_adj_nonsig, gwas_mlmm_adj) %>%
  select(-se) %>%
  mutate(neg_log10_fdr05 = -log10(0.05),
         neg_log10_fdr10 = -log10(0.10))


# Plot the results of genotypic mean
g_man_g <- gwas_pheno_mean_fw_adj_mlmm %>%
  filter(coef == "g") %>%
  mutate(chrom = as.factor(chrom)) %>% 
  ggplot(aes(x = pos / 1000000, y = q_value_neg_log10, group = chrom, col = chrom)) + 
  facet_grid(trait ~ chrom, switch = "x", scales = "free", space = "free_x") +
  g_add

# Save
save_file <- file.path(fig_dir, "gwas_pheno_genotype_mean_manhattan_mlmm.jpg")
ggsave(filename = save_file, plot = g_man_g, width = 9, height = 8)

# Plot the results of stability
g_man_stab <- gwas_pheno_mean_fw_adj_mlmm %>%
  filter(coef != "g") %>%
  mutate(chrom = as.factor(chrom),
         coef = if_else(coef == "b", "Linear", "Non-Linear")) %>% 
  ggplot(aes(x = pos / 1000000, y = q_value_neg_log10, group = chrom, col = chrom)) + 
  facet_grid(trait + coef ~ chrom, switch = "x", scales = "free", space = "free_x") +
  g_add

# Save
save_file <- file.path(fig_dir, "gwas_pheno_fw_manhattan_mlmm.jpg")
ggsave(filename = save_file, plot = g_man_stab, width = 9, height = 8)



```


What are the numbers of significant marker-trait assocations for each trait and type?

Create a table

```{r summary.assoc.}

gwas_sig_snp_summ <- gwas_pheno_mean_fw_adj %>% 
  filter(model == "G") %>% 
  group_by(trait, coef, chrom) %>% 
  summarize(n_sig_SNP = sum(q_value <= 0.05)) %>%
  mutate(type = "GWAS")

mlmm_sig_snp_summ <- gwas_mlmm_Gmodel %>% 
  ungroup() %>% 
  complete(trait, coef, chrom) %>% 
  group_by(trait, coef, chrom) %>% 
  summarize(n_sig_SNP = sum(q_value <= 0.05, na.rm = T)) %>%
  mutate(type = "MLMM")

# Combine with the multi-locus mixed model results
gwas_pheno_mean_fw_sig <- bind_rows(gwas_sig_snp_summ, mlmm_sig_snp_summ)


```


Adjust the manhattan plots to show the markers that were declared significant
in the mlmm with different colors

```{r highlight.sig.mar}

# Filter the GWAS results
gwas_pheno_mean_fw_focus <- gwas_pheno_mean_fw_adj %>% 
  filter(model == "G") %>% 
  unnest() %>%
  select(trait, coef, marker:pos, alpha = estimate, p_value, q_value)

# Get the SNPs not in the mlmm df
gwas_pheno_not_sig <- anti_join(gwas_pheno_mean_fw_focus, gwas_mlmm_Gmodel, 
                                by = c("trait", "coef", "marker", "chrom", "pos")) %>%
  mutate(significant = FALSE)

# Combine
gwas_results_toplot <- gwas_mlmm_Gmodel %>%
  ungroup() %>%
  select(-se) %>%
  mutate(significant = TRUE) %>%
  bind_rows(., gwas_pheno_not_sig) %>%
  mutate(neg_log_qvalue = -log10(q_value),
         coef = case_when(coef == "g" ~ "Genotype Mean",
                          coef == "b" ~ "Linear Stability",
                          coef == "log_delta" ~ "Non-Linear Stability"), 
         coef = parse_factor(coef, levels = c("Genotype Mean", "Linear Stability", "Non-Linear Stability")),
         color = case_when(chrom %in% seq(1, 7, by = 2) & !significant ~ "B",
                           !chrom %in% seq(1, 7, by = 2) & !significant ~ "G",
                           TRUE ~ "Bl"))

# Color scheme
color <- c("Bl" = umn_palette(n = 3)[3], "B" = "black", "G" = "grey75")

## Plot
g_gwas_complete_plot <- gwas_results_toplot %>% 
  ggplot(aes(x = pos / 1000000, y = neg_log_qvalue, color = color)) + 
  geom_point() + 
  geom_hline(yintercept = -log10(0.05), lty = 2) + 
  scale_color_manual(values = color, guide = FALSE) +
  ylab(expression(-log[10]~(italic(q)))) +
  xlab("Position (Mbp)") + 
  facet_grid(trait + coef ~ chrom, scales = "free", space = "free_x", switch = "x") + 
  theme_manhattan()

# Save this
save_file <- file.path(fig_dir, "gwas_manhattan_complete.jpg")
ggsave(filename = save_file, plot = g_gwas_complete_plot, width = 9, height = 12)


```





Combine the mean and stability manhattan plots into a single graph


```{r plot.mean.and.stability}

# Model to use
model_toplot <- "G"

# Combine mean and stability into a single df.
# Convert the stability -log10(q) values into their opposites (i.e. *-1)
gwas_geno_mean_use <- gwas_pheno_mean_fw_adj %>%
  ungroup() %>%
  filter(model == "QG", coef == "g")  %>%
  select(marker:trait, contains("neg_log10_fdr"), Mean = q_value_neg_log10)

gwas_pheno_fw_use <- gwas_pheno_mean_fw_adj %>%
  ungroup() %>%
  filter(model == "QG", coef != "g") %>%
  mutate(coef = if_else(coef == "b", "linear", "non-linear")) %>%
  select(marker:trait, contains("neg_log10_fdr"), coef, Stability = q_value_neg_log10)

# Extract the palette for use in the manhattan plot
palette_use <- umn_palette("Secondary_Tier2")[c(3,8,4,9)]
odd_chrom <- seq(1, 7, by = 2)

gwas_use <-  gwas_pheno_fw_use %>%
  filter(coef == "linear") %>%
  full_join(gwas_geno_mean_use, .) %>%
  gather(test, q_value_neg_log10, -marker:-neg_log10_fdr10, -coef) %>%
  mutate_at(vars(q_value_neg_log10, contains("neg_log10_fdr")), funs(if_else(test == "Stability", . * -1, .))) %>%
  mutate(color = case_when(chrom %in% odd_chrom & test == "Mean" ~ "palette1",
                           !chrom %in% odd_chrom & test == "Mean" ~ "palette2",
                           chrom %in% odd_chrom & test == "Stability" ~ "palette3",
                           !chrom %in% odd_chrom & test == "Stability" ~ "palette4"),
         chrom = as.factor(chrom))

# color vector for ggplot
color_value <- set_names(palette_use, unique(gwas_use$color))

# Create the combo plot
## Create the common modifier
g_mod <- list(
  geom_hline(yintercept = 0),
  geom_point(aes(col = color)),
  geom_hline(aes(yintercept = neg_log10_fdr05, lty = "FDR 05%")),
  geom_hline(aes(yintercept = neg_log10_fdr10, lty = "FDR 10%")),
  facet_grid(trait ~ chrom, switch = "x", scales = "free_x", space = "free_x"),
  scale_linetype_discrete(guide = FALSE),
  scale_color_manual(values = color_value, labels = c("Mean", "Mean", "Stability", "Stability"),
                     guide = FALSE),
  # ylab("-log(q)"),
  # xlab("Position (Mbp)"),
  # labs(title = "Genomewide Assocation Analyses"),
  theme_manhattan()
)


## Plot GrainYield
g_mean_fw_gy <- gwas_use %>%
  filter(trait == "GrainYield") %>%
  ggplot(aes(x = pos / 1000000, y = q_value_neg_log10)) +
  ylim(c(-1.5, 1.5)) +
  g_mod +
  theme(axis.text.x = element_blank(),
        strip.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title = element_blank())

## Plot HeadingDate
g_mean_fw_hd <- gwas_use %>%
  filter(trait == "HeadingDate") %>%
  ggplot(aes(x = pos / 1000000, y = q_value_neg_log10)) +
  ylim(c(-4, 4)) +
  g_mod +
  ylab(expression(-log[10](italic(q)))) +
  theme(axis.text.x = element_blank(),
        strip.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank())

## Plot PlantHeight
g_mean_fw_ph <- gwas_use %>%
  filter(trait == "PlantHeight") %>%
  ggplot(aes(x = pos / 1000000, y = q_value_neg_log10)) +
  ylim(c(-4.5, 4.5)) +
  g_mod +
  xlab("Position (Mbp)") +
  theme(axis.title.y = element_blank())

# Create grobs
grobs <- list(g_mean_fw_gy, g_mean_fw_hd, g_mean_fw_ph) %>%
  map(ggplotGrob)

save_file <- file.path(fig_dir, "gwas_pheno_mean_and_linear_stability.jpg")
ggsave(filename = save_file, plot = do.call("rbind", grobs), width = 9, height = 6)




## Plot non-linear stability
gwas_use <-  gwas_pheno_fw_use %>%
  filter(coef == "non-linear") %>%
  full_join(gwas_geno_mean_use, .) %>%
  gather(test, q_value_neg_log10, -marker:-neg_log10_fdr10, -coef) %>%
  mutate_at(vars(q_value_neg_log10, contains("neg_log10_fdr")), funs(if_else(test == "Stability", . * -1, .))) %>%
  mutate(color = case_when(chrom %in% odd_chrom & test == "Mean" ~ "palette1",
                           !chrom %in% odd_chrom & test == "Mean" ~ "palette2",
                           chrom %in% odd_chrom & test == "Stability" ~ "palette3",
                           !chrom %in% odd_chrom & test == "Stability" ~ "palette4"),
         chrom = as.factor(chrom))

# Create the combo plot
## Create the common modifier
g_mod <- list(
  geom_hline(yintercept = 0),
  geom_point(aes(col = color)),
  geom_hline(aes(yintercept = neg_log10_fdr05, lty = "FDR 05%")),
  geom_hline(aes(yintercept = neg_log10_fdr10, lty = "FDR 10%")),
  facet_grid(trait ~ chrom, switch = "x", scales = "free_x", space = "free_x"),
  scale_linetype_discrete(guide = FALSE),
  scale_color_manual(values = color_value, labels = c("Mean", "Mean", "Stability", "Stability"),
                     guide = FALSE),
  # ylab("-log(q)"),
  # xlab("Position (Mbp)"),
  # labs(title = "Genomewide Assocation Analyses"),
  theme_manhattan()
)


## Plot GrainYield
g_mean_fw_gy <- gwas_use %>%
  filter(trait == "GrainYield") %>%
  ggplot(aes(x = pos / 1000000, y = q_value_neg_log10)) +
  ylim(c(-1.5, 1.5)) +
  g_mod +
  theme(axis.text.x = element_blank(),
        strip.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title = element_blank())

## Plot HeadingDate
g_mean_fw_hd <- gwas_use %>%
  filter(trait == "HeadingDate") %>%
  ggplot(aes(x = pos / 1000000, y = q_value_neg_log10)) +
  ylim(c(-7, 7)) +
  g_mod +
  ylab(expression(-log[10](italic(q)))) +
  theme(axis.text.x = element_blank(),
        strip.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank())

## Plot PlantHeight
g_mean_fw_ph <- gwas_use %>%
  filter(trait == "PlantHeight") %>%
  ggplot(aes(x = pos /  1000000, y = q_value_neg_log10)) +
  ylim(c(-3.5, 3.5)) +
  g_mod +
  xlab("Position (Mbp)") +
  theme(axis.title.y = element_blank())

# Create grobs
grobs <- list(g_mean_fw_gy, g_mean_fw_hd, g_mean_fw_ph) %>%
  map(ggplotGrob)

save_file <- file.path(fig_dir, "gwas_pheno_mean_and_nonlinear_stability.jpg")
ggsave(filename = save_file, plot = do.call("rbind", grobs), width = 9, height = 6)


```


#### Significant associations

Look at the significant markers and assess the effect size, minor allele frequency, etc.

```{r sig.markers}

# Calculate the allele frequency of the 1 allele
af1 <- {colMeans(M + 1) / 2} %>%
  data.frame(marker = names(.), af = ., row.names = NULL, stringsAsFactors = FALSE)

# Combine the minor allele frequency information
gwas_mlmm_marker_info <- gwas_mlmm_Gmodel %>% 
  ungroup() %>%
  left_join(., af1) %>%
  mutate(allele_count = af * nrow(M))



# Subset the marker matrix for these SNPs and count the number of lines
# from each program with each allele
gwas_mlmm_marker_prop <- gwas_mlmm_marker_info %>%
  group_by(marker) %>%
  do({
    df <- .
    
    # Extract the data on the marker
    marker_geno <- M[,df$marker, drop = FALSE] %>% 
      as.data.frame() %>% rownames_to_column("line_name") %>% 
      mutate(program = str_extract(line_name, "[A-Z][A-Z0-9]")) %>%
      select(line_name, program, marker = df$marker)
    
    # Round the marker genotype
    marker_geno_round <- marker_geno %>% 
      mutate(allele = case_when(marker <= -0.5 ~ -1,
                                marker >= 0.5 ~ 1,
                                TRUE ~ 0),
             allele = allele + 1)
    
    # Calculate the % of lines from each program that have the 1 allele
    marker_geno_prop <- marker_geno_round %>% 
      group_by(program) %>% 
      summarize(prop_1_allele = mean(allele) / 2) %>% 
      spread(program, prop_1_allele) 
    
    # Return the df
    bind_cols(df, marker_geno_prop)
    
  })

gwas_mlmm_marker_toprint <- gwas_mlmm_marker_prop %>%
  ungroup() %>%
  left_join(., snp_info) %>%
  select(trait, coef, marker, chrom, pos, cM = cM_pos, alpha, q_value, af, AB:WA) %>%
  mutate(coef = str_replace_all(coef, c("b" = "Linear Stability", "log_delta" = "Non-Linear Stability", 
                                  "g" = "Genotype Mean")),
         MAF = pmin(af, 1 - af)) %>%
  rename_at(.vars = vars(trait:pos), .funs = str_to_title) %>%
  select(Trait:cM, MAF, alpha:q_value, AB:WA) %>%
  arrange(Trait, Coef, Chrom, Pos)
         


# Write a table
save_file <- file.path(fig_dir, "significant_associations.csv")
write_csv(x = gwas_mlmm_marker_toprint, path = save_file)

    
# Look at the heading date QTL on chromosome 5 (VrnH1?)
gwas_mlmm_marker_prop %>% 
  filter(trait == "HeadingDate", chrom == 5)

# Look at chromosome 7 for plant height
gwas_mlmm_marker_prop %>% 
  filter(trait == "PlantHeight", chrom == 6)

  


```




#### Resampling the Number of Environments

I want to know how many of the same QTL for stability are recovered when we estimate 
stability using a different number of environments.

I resampled 20, 40, 60, or 80% of environments 100 times each, calculate the stability
estimates, then performed the mapping.

```{r resampling.results}

# Read in the results
load(file.path(result_dir, "S2MET_pheno_fw_gwas_resample_results.RData"))

# Bind rows
resample_gwas_sig_out1 <- resample_gwas_sig_out %>%
  bind_rows()

## Filter the original GWAS results for the stability QTL and the G model
gwas_sig_fw <- gwas_pheno_mean_fw_adj %>% 
  filter(model == "G", 
         coef != "g", 
         q_value <= alpha)

# Iterate over the resampling results and find the signficant loci at alpha
resample_gwas_sig_fw <- resample_gwas_sig_out1 %>%
  select(p, iter, sig_out) %>% 
  unnest() %>%
  # SPlit the trait into trait and coefficient
  separate(col = trait, into = c("trait", "coef"), sep = "_", extra = "merge") %>% 
  filter(q_value <= alpha)

## First, for each proportion of environments and for each level of stability,
## how many significant SNPs were detected?
resample_gwas_sig_fw_count <- resample_gwas_sig_fw %>% 
  group_by(p, iter, trait, coef) %>% 
  summarize(n_SNP = n()) %>%
  ungroup() %>%
  complete(p, iter, trait, coef, fill = list(n_SNP = 0)) %>%
  group_by(p, trait, coef) %>%
  mutate_at(vars(n_SNP), funs(mean, sd)) %>%
  ungroup()

## Plot this
g_resample_n_SNPs <- resample_gwas_sig_fw_count %>% 
  ggplot(aes(x = p, y = mean, col = trait, group = trait)) + 
  geom_point() + 
  geom_line() + 
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.25) + 
  ylab("Number of Significant SNPs") +
  xlab("Proportion of Environments Sampled") +
  facet_grid(~ coef) + 
  theme_bw()

# Table


# Subset the original gwas results
gwas_sig_fw_intersect <- gwas_sig_fw %>%
  select(marker, trait, coef)

# For each p, iter, trait, and coef, how often do we detect new SNPs or the same
# SNPs as in the full analysis?
resample_gwas_sig_fw_intersect <- resample_gwas_sig_fw %>% 
  select(p, iter, marker, trait, coef) %>%
  group_by(p, iter, trait, coef) %>%
  do({
    df <- .
    
    # Trait and coef
    tr <- unique(df$trait)
    co <- unique(df$coef)
    
    # Filter the original data
    gwas_sig_fw_intersect1 <- gwas_sig_fw_intersect %>%
      filter(trait == tr, coef == co)
    
    # Intersect
    marker_intersect <- intersect(df$marker, gwas_sig_fw_intersect1$marker)
    marker_new <- setdiff(df$marker, gwas_sig_fw_intersect1$marker)
    
    # Return a data.frame of the intersected markers, the unique markers, and the counts of each
    data_frame(hit_SNPs = list(marker_intersect), 
               new_SNPs = list(marker_new))  })

resample_gwas_sig_fw_intersect1 <- resample_gwas_sig_fw_intersect %>% 
  ungroup() %>% 
  gather(SNP_type, SNPs, -p:-coef) %>% 
  mutate(n_SNPs = map_dbl(SNPs, length)) %>% 
  group_by(p, trait, coef, SNP_type) %>% 
  summarize_at(vars(n_SNPs), funs(mean, sd)) %>%
  ungroup()

## Remember, the above measures the number of intersected or new SNPs conditional
## on actually detected significant associations

# Number of iterations
n_iter <- n_distinct(resample_gwas_sig_fw$iter)


# Plot
g_resample_intersect <- resample_gwas_sig_fw_intersect1 %>% 
  ggplot(aes(x = p, y = mean, fill = SNP_type, group = SNP_type)) + 
  geom_col(position = "dodge") + 
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.25, 
                position = position_dodge(0.9)) + 
  ylab("Number of SNPs") +
  xlab("Proportion of Environments Sampled") +
  facet_grid(trait ~ coef, scales = "free_y") + 
  theme_bw()

save_file <- file.path(fig_dir, "resample_gwas_intersection.jpg")
ggsave(filename = save_file, plot = g_resample_intersect, width = 6, height = 5)


## Count up the intersected and new SNPs and rank by number of times
## the SNP was detected

resample_snp_detect_count <- resample_gwas_sig_fw_intersect %>% 
  ungroup() %>% 
  gather(SNP_type, marker, -p:-coef) %>%
  unnest() %>% 
  group_by(p, trait, coef, SNP_type, marker) %>% 
  summarize(times_detected = n(), prop_detected = times_detected / n_iter) %>%
  ungroup() %>%
  left_join(., select(S2TP_imputed_multi_genos_hmp, marker = rs, chrom, pos), by = "marker") %>%
  # Assign proportion bins 
  mutate(prop_group = cut(x = prop_detected, breaks = seq(0, 1, 0.2), include.lowest = TRUE, right = TRUE))

# Are we more likely to discover new SNPs or those we discovered before?
g_resample_snp_detect_count <- resample_snp_detect_count %>%
  mutate_at(vars(p, trait, coef, SNP_type), funs(as.factor)) %>% 
  complete(p, trait, coef, SNP_type, fill = list(prop_detected = 0)) %>%
  ggplot(aes(x = p, y = prop_detected, color = SNP_type)) +
  geom_boxplot(position = "dodge", width = 0.5) +
  scale_color_discrete(drop = FALSE) +
  facet_grid(trait ~ coef) + 
  theme_bw() +
  labs(subtitle = "Proportion of samples in which any one SNP is considered significant")

save_file <- file.path(fig_dir, "resample_gwas_intersection_prop.jpg")
ggsave(filename = save_file, plot = g_resample_snp_detect_count, width = 6, height = 5)


# Sort and display
resample_snp_detect_count_max <- resample_snp_detect_count %>%
  filter(times_detected == max(times_detected))
  

# Common plot modifier
g_mod <- list(geom_point(),
  geom_segment(data = barley_lengths, aes(x = 0, y = 0, xend = 0, yend = length / 1000000), 
               inherit.aes = FALSE, size = 2, lineend = "round", col = "grey70") ,
  ylab("Position (Mbp)") ,
  xlim(c(-2, 2)) , 
  facet_grid(~ chrom, switch = "x") , 
  scale_shape_manual(values = c("hit_SNPs" = 1, "new_SNPs" = 0)) , 
  # scale_size_manual(breaks = seq(0, 1, by = 0.25)),
  scale_y_reverse() , 
  theme_bw() , 
  theme(panel.grid = element_blank(), 
        panel.border = element_blank(), 
        # panel.spacing.x = unit(1, units = "cm"),
        axis.text.x = element_blank(), 
        axis.title.x = element_blank(), 
        axis.ticks.x = element_blank(),
        strip.background = element_blank()) )


# Create a 'heatmap' for each trait
g_resample_hd <- resample_snp_detect_count %>% 
  mutate(p = parse_number(p),
         x = if_else(SNP_type == "hit_SNPs", -p * 2, p * 2)) %>% 
  filter(trait == "HeadingDate") %>% 
  ggplot(aes(y = pos / 1000000, x = x, size = prop_group, col = coef, shape = SNP_type)) + 
  g_mod +
  labs(title = "Heading Date")

g_resample_ph <- resample_snp_detect_count %>% 
  mutate(p = parse_number(p),
         x = if_else(SNP_type == "hit_SNPs", -p * 2, p * 2)) %>% 
  filter(trait == "PlantHeight") %>% 
  ggplot(aes(y = pos / 1000000, x = x, size = prop_group, col = coef, shape = SNP_type)) + 
  g_mod +
  labs(title = "Plant Height")

g_resample_gy <- resample_snp_detect_count %>% 
  mutate(p = parse_number(p),
         x = if_else(SNP_type == "hit_SNPs", -p * 2, p * 2)) %>% 
  filter(trait == "GrainYield") %>% 
  ggplot(aes(y = pos / 1000000, x = x, size = prop_group, col = coef, shape = SNP_type)) + 
  g_mod +
  labs(title = "Grain Yield")

## Plot together
save_file <- file.path(fig_dir, "resample_count_hd.jpg")
ggsave(filename = save_file, plot = g_resample_hd, width = 10, height = 7, dpi = 1000)

save_file <- file.path(fig_dir, "resample_count_ph.jpg")
ggsave(filename = save_file, plot = g_resample_ph, width = 10, height = 7, dpi = 1000)

save_file <- file.path(fig_dir, "resample_count_gy.jpg")
ggsave(filename = save_file, plot = g_resample_gy, width = 10, height = 7, dpi = 1000)

```


#### Intervals around significant associations



Group significant SNPs for each trait that are within 5 Mbp and in high LD ($r^2 \ge 0.80$). 


```{r sig.overlap}

## Write a function that uses distance and LD to group SNPs
snp_clust <- function(grange, LD, wind.size, LD.threshold) {
  
  # Grab the SNP positions
  pos <- start(grange)
  # Grab the marker names
  mar_names <- names(grange)
  
  # Start some vectors
  dist_list <- LD_list <- vector("numeric", length(grange))
  
  # Start a distance group and LD group count
  dist_group <- LD_group <- 1
  
  # Add the first SNP to group 1
  dist_list[1] <- LD_list[1] <- dist_group
  
  # Start the snp counter
  i = 2
  # Iterate over the markers in order
  while (i <= length(grange)) {
    
    # Is marker i within the window size of the previous marker?
    window <- c(pos[i] - wind.size, pos[i] + wind.size)
    is_within <- between(pos[i - 1], left = window[1], right = window[2])
    
    # If so, add this marker to the dist group of the previous
    if (is_within) {
      dist_list[i] <- dist_group
    } else {
      dist_group <- dist_group + 1
      dist_list[i] <- dist_group
    }
    
    i_dist_group <- setdiff(which(dist_list == dist_group), i)
    # Is marker i within the LD cutoff of any of the markers in the same distance group?
    is_in_LD <- any(LD[i, i_dist_group] >= LD.threshold)
    
    # If so, add this marker to the LD group of the previous
    if (is_in_LD) {
      LD_list[i] <- LD_group
    } else {
      LD_group <- LD_group + 1
      LD_list[i] <- LD_group
    }
    
    # enumerate i
    i <- i + 1
    
  }
  
  # Group
  data.frame(marker = mar_names, group = as.numeric(as.factor(dist_list + LD_list)), 
             stringsAsFactors = FALSE)
  
}
  
# LD threshold for grouping markers
LD_threshold <- 0.80
# Window size for genomic region
# Note that half of this value will be used for overlaps
wind_size <- 10000000

# Create GRanges objects
sig_markers_GRange <- gwas_mlmm_Gmodel %>%
  ungroup() %>%
  mutate(snp_pos = pos) %>%
  group_by(trait, coef, chrom) %>%
  do(grange = {
    df <- . 
    makeGRangesFromDataFrame(
      df = df, keep.extra.columns = TRUE, ignore.strand = TRUE, seqnames.field = "chrom", 
      start.field = "pos", end.field = "pos") %>% 
      `ranges<-`(., value = IRanges(start = start(.) - (wind_size / 2), end = end(.) + (wind_size / 2))) })

# Calculate LD between all markers for each group,
# then use the LD to cluster markers
sig_markers_groups <- sig_markers_GRange %>% 
  group_by(trait, coef, chrom) %>%
  do(grange = {
    grange <- .$grange[[1]]
    
    # If only one SNP, return a regular data.frame
    if (length(grange) == 1) {
      grange$group <- "group1"
      
    } else {
    
      # Calculate LD
      LD <- cor(M[,grange$marker])^2
      
      # Add names to the grange
      names(grange) <- grange$marker
      
      # Cluster
      groups <- snp_clust(grange = grange, LD = LD, wind.size = wind_size, LD.threshold = LD_threshold)
      grange$group <- str_c("group", groups$group)
    }
    
    grange
  })

# Combine the data
sig_markers_grange_df <- sig_markers_groups$grange %>% 
  map_df(as.data.frame) %>% 
  as_data_frame() %>%
  dplyr::rename(chrom = seqnames)

# Save this
save_file <- file.path(result_dir, "S2MET_gwas_sig_loci.RData")
save("sig_markers_grange_df", file = save_file)


```




Summarize the number of significant markers and intervals

```{r summ.intervals}

## Summarize the number of significant markers and the number of sgnificant intervals
sig_summary <- sig_markers_grange_df %>% 
  group_by(trait, coef, chrom) %>% 
  summarize(SNP = n_distinct(marker), Interval = n_distinct(group)) %>% 
  summarize_at(vars(SNP, Interval), sum)

# Translator for coefficient
coef_repl <- function(x) {
  case_when(x == "log_delta" ~ "Non-Linear Stability",
            x == "g" ~ "Genotype Mean", 
            x == "b" ~ "Linear Stability")
}

## Plot the intervals
# First change the coefficient to a factor and create y axis 
g_sig_interval <- sig_markers_grange_df %>% 
  mutate(coef = parse_factor(coef, levels = c("g", "b", "log_delta")),
         y_coef = as.numeric(coef) / 2) %>% 
  ggplot() + 
  geom_segment(aes(x = y_coef, xend = y_coef, y = start / 1000000, 
                   yend = end / 1000000, col = coef), size = 3) + 
  geom_segment(data = barley_lengths, aes(x = 0, y = 0, xend = 0, yend = length / 1000000), 
               inherit.aes = FALSE, size = 2, lineend = "round", col = "grey70") + 
  ylab("Position (Mbp)") +
  xlim(c(-1, 2)) +
  facet_grid(trait ~ chrom, switch = "x") + 
  scale_y_reverse() +
  theme_bw() +
  theme(panel.grid = element_blank(), 
        panel.border = element_blank(), 
        panel.spacing.y = unit(0.5, units = "cm"),
        axis.text.x = element_blank(), 
        axis.title.x = element_blank(), 
        axis.ticks.x = element_blank(),
        strip.background = element_blank())

save_file <- file.path(fig_dir, "significant_loci_intervals.jpg")
ggsave(filename = save_file, plot = g_sig_interval, height = 7, width = 9)


```

Create genomic ranges for each of the trait-coef combinations

```{r sep.Granges}

grange_sep <- sig_markers_grange_df %>% 
  group_by(trait, coef) %>% 
  do(Grange = GRanges(.)) %>%
  ungroup()

# Group by trait and find potential overlap between genotype mean intervals and
# plasticity intervals
grange_compare <- grange_sep %>% 
  group_by(trait) %>% 
  do({
    df <- .
    
    # Data.frame of combinations
    combn_df <- combn(x = df$coef, m = 2) %>%
      t() %>%
      as.data.frame() %>%
      `colnames<-`(., c("coef1", "coef2")) %>%
      map(~as.character(.))
    
    # Iterate over the combinations
    compare_out <- map2(.x = combn_df$coef1, .y = combn_df$coef2, 
                        function(c1, c2) {
        grange1 <- subset(df, coef == c1)$Grange[[1]]
        grange2 <- subset(df, coef == c2)$Grange[[1]]
        
        # Calculate the distance to neareast and add the grange information
        dtn <- suppressWarnings(distanceToNearest(x = grange1, subject = grange2)) %>%
          as_data_frame() %>% 
          mutate(queryGrange = map(queryHits, ~grange1[.]), 
                 subjectGrange = map(subjectHits, ~grange2[.]))
        })
    
    # Return the comparisons
    combn_df %>% 
      as_data_frame() %>%
      mutate(comparison = compare_out) })
    

# Look at the comparisons where overlap is present and determine the LD between
# the SNP in those intervals
grange_compare_LD <- grange_compare %>%
  unnest() %>% 
  filter(distance == 0) %>%
  do({
    
    df <- .
    
    # Extract the markers
    overlap_df_grange <- df %>% 
      select(trait:coef2, contains("Grange")) %>%
      gather(temp, coef, coef1, coef2) %>% 
      gather(temp1, Grange, contains("Grange")) %>% 
      filter(temp == "coef1" & temp1 == "queryGrange" | temp == "coef2" & temp1 == "subjectGrange") %>% 
      select(-contains("temp")) %>% 
      mutate(Grange = map(Grange, as.data.frame)) %>% 
      unnest()
    
    # Return the LD
    overlap_df_grange %>% 
      select(trait, coef, chrom = seqnames, start, end, marker:group) %>% 
      mutate(LD = cor(M[,overlap_df_grange$marker])[1,2]^2)
      
  })
        
grange_compare_LD %>% 
  select(trait, coef, chrom, alpha, q_value, snp_pos, LD)


```





For each of the significant intervals, plot the LD of those markers with nearby markers within 10 Mbp

```{r zoom.LD}

# In each group, select the marker with the highest p-value
sig_markers_grange_df_select <- sig_markers_grange_df %>% 
  group_by(trait, coef, chrom, group) %>% 
  filter(p_value == min(p_value))

# Calculate LD across all markers on each chromosome
snp_LD <- snp_info %>% 
  split(.$chrom) %>% 
  map("marker") %>% 
  map(~cor(M[,.])^2)

# Iterate over each marker and calculate the LD between that marker
# and all nearby markers within the interval
sig_markers_grange_df_select_LD <- sig_markers_grange_df_select %>%
  group_by(trait, coef, marker) %>%
  do({
    df <- .
    
    nearby_markers <- snp_info %>% 
      filter(chrom == df$chrom, between(pos, left = df$start, right = df$end),
             marker != df$marker)
    
    # Extract LD
    df_LD <- snp_LD[[df$chrom]][df$marker, nearby_markers$marker]
    
    # Add the LD to the nearby markers and return
    to_return <- nearby_markers %>% 
      mutate(LD = df_LD) 
    
    df %>% 
      select(chrom, snp_pos, alpha:q_value) %>% 
      mutate(snp_LD = list(to_return)) })

# Plot the significant marker and the LD of the surrounding markers
g_sig_marker_LD <- sig_markers_grange_df_select_LD %>% 
  unnest() %>% 
  ggplot() + 
  geom_point(aes(x = pos / 1000000, y = LD)) + 
  geom_vline(aes(xintercept = snp_pos / 1000000)) + 
  ylab(expression(r^2)) + 
  xlab("Position (Mbp)") + 
  ylim(c(0,1)) +
  facet_wrap_paginate(~ trait + coef + marker, nrow = 3, ncol = 3, scales = "free_x")

# Iterate over the pages and save



```









Window overlap

First find the overlap between mean and stability and quantify

Then find the overlap between stability and marker effect stability

```{r window.overlap}

# Convert the mean and stability intervals into GRanges
sig_intervals <- sig_loci_df_intervals %>% 
  droplevels() %>% 
  mutate(seqnames = str_c("chr", .$chrom, "H")) %>%
  distinct(trait, assoc_test, interval_start, interval_end, seqnames) %>%
  group_by(assoc_test, trait) %>% 
  do(range = GRanges(seqnames = .$seqnames, ranges = IRanges(start = .$interval_start, end = .$interval_end))) %>%
  select(trait, names(.)) %>%
  spread(assoc_test, range)



# Write a function that takes two lists of Ranges and finds the overlaps
# and number of overlaps
find_overlaps <- function(q, s) {
  # If null, return NA
  if (is.null(q) | is.null(s)) {
    data_frame(hits = list(NA), query_hits = list(NA), subject_hits = list(NA),
               query_length = as.integer(NA), subject_length = as.integer(NA),
               query_hits_n = as.integer(NA), subject_hits_n = as.integer(NA))
               
    
  } else {
    # Find overlaps
    hits <- suppressWarnings(findOverlaps(query = q, subject = s))
    # Data frame of query and subject hits, lengths, number
    data_frame(hits = list(hits)) %>% 
      mutate(query_hits = map(hits, ~q[queryHits(.),]), 
             subject_hits = map(hits, ~s[subjectHits(.),]),
             query_length = length(q), subject_length = length(s)) %>% 
      mutate_at(vars(contains("_hits")), funs(n = map_dbl(., length)))
  }
}



# For each trait, find the overlaps between mean and stability
interval_overlaps <- sig_intervals %>% 
  mutate(mean_linear_stability_overlap = list(main_effect_mean, linear_stability) %>% pmap(find_overlaps),
         mean_nonlinear_stability_overlap = list(main_effect_mean, `non-linear_stability`) %>% pmap(find_overlaps),
         linear_stability_mar_linear_stability_overlap = list(linear_stability, linear_marker_stability) %>% pmap(find_overlaps),
         linear_stability_mar_linear_plasticity_overlap = list(linear_stability, linear_marker_plasticity) %>% pmap(find_overlaps),
         nonlinear_stability_mar_nonlinear_stability_overlap = list(`non-linear_stability`, `non-linear_marker_plasticity`) %>% pmap(find_overlaps) )
    
# Extract the data.frame results
interval_overlaps_df <- interval_overlaps %>% 
  select(trait, contains("overlap")) %>% 
  gather(overlap, data, -trait) %>% 
  unnest() %>% 
  # Calculate proportions
  mutate(prop_query_hits = query_hits_n / query_length,
         prop_subject_hits = subject_hits_n / subject_length)

interval_overlaps_df %>% select(trait, overlap, query_hits_n:prop_subject_hits)

```


Gene models in the intervals

For the main effect and stability intervals, find gene annotations

```{r gene.ann}

# Load a venn diagram package
library(Vennerable)

# Load the gene annotation data
load("C:/Users/Jeff/Google Drive/Barley Lab/Projects/Genomics/Annotation/barley_genomic_ranges.RData")

# OVerlap the intervals and merge
sig_intervals_annotation <- sig_intervals %>% 
  gather(test, range, -trait) %>%
  filter(!map_lgl(range, is.null)) %>%
  mutate(overlap = map(range, ~mergeByOverlaps(query = ., subject = barley_grange_list$genes)))

# Save the cross-overlaps and the overlaps with the gene models
save_file <- file.path(result_dir, "genomewide_analysis_interval_overlaps.RData")
save("interval_overlaps_df", "sig_intervals_annotation", file = save_file)

  
# For each trait and test, extact a list if unique gene IDs
sig_intervals_gene_ids <- sig_intervals_annotation %>% 
  mutate(gene_ids = map(overlap, ~unique(.$gene_id)))

# Create set lists for Venn diagrams
sig_intervals_venn <- sig_intervals_gene_ids %>% 
  group_by(trait) %>% 
  do(gene_venn = set_names(.$gene_ids, .$test) %>% Venn)


# Plot a venn diagram of the gene ID overlaps between mean, stability, and marker stability
sig_intervals_venn$gene_venn %>% map(~plot(., doWeights = FALSE, type = if_else(NumberOfSets(.) < 4, "circles", "ellipses")))


```






## Appendix

### Archive

```{r}




###
# ### Archived code for testing the TP and TP + VP
# 
# # Tranpose the list
# gwas_pheno_fw1 <- transpose(gwas_pheno_fw)
# 
# # Add the model name to the df
# gwas_pheno_fw2 <- gwas_pheno_fw1 %>% 
#   map(~map_df(., ~mutate(.$scores, model = .$metadata$model) %>%
#                 filter(term == "main_effect")))
# 
# ## Adjust the p-values
# gwas_pheno_fw_adj <- gwas_pheno_fw2 %>%
#   map(~group_by(., trait, model) %>% 
#         mutate(p_adj = p.adjust(p_value, method = "fdr"),
#                q_value = qvalue(p = p_value)$qvalue,
#                neg_log10_fdr05 = -log10(0.05),
#                neg_log10_fdr10 = -log10(0.10)) %>%
#         mutate_at(vars(p_value, p_adj, q_value), funs(neg_log10 = -log10(.))) )
# 
# 
# ## Quality control
# ## QQ plot
# qq_gwas_pheno_fw_adj <- gwas_pheno_fw_adj %>% 
#   map(~arrange(., trait, model, p_value) %>% 
#         mutate(p_exp = punif(q = seq(0, 1, length.out = n())), 
#                neg_log10_p_exp = -log10(p_exp)))
# 
# # Plot
# g_qq_all <- qq_gwas_pheno_fw_adj$pop_all %>%
#   ggplot(aes(x = neg_log10_p_exp, y = p_value_neg_log10, col = model)) + 
#   geom_point() + 
#   geom_abline(slope = 1, intercept = 0) + 
#   facet_wrap(~ trait, ncol = 2) +
#   labs(title = "QQ Plot", subtitle = "TP and VP") +
#   theme_bw()
# 
# save_file <- file.path(fig_dir, "gwas_pheno_fw_qq_all.jpg")
# ggsave(filename = save_file, plot = g_qq_all, width = 5, height = 7)
# 
# 
# g_qq_tp <- qq_gwas_pheno_fw_adj$pop_tp %>%
#   ggplot(aes(x = neg_log10_p_exp, y = p_value_neg_log10, col = model)) + 
#   geom_point() + 
#   geom_abline(slope = 1, intercept = 0) + 
#   facet_wrap(~ trait, ncol = 2) +
#   labs(title = "QQ Plot", subtitle = "TP") +
#   theme_bw()
# 
# save_file <- file.path(fig_dir, "gwas_pheno_fw_qq_tp.jpg")
# ggsave(filename = save_file, plot = g_qq_tp, width = 5, height = 7)
# 
# 
# ## Manhattan plot
# g_man_all <- gwas_pheno_fw_adj$pop_all %>%
#   mutate(chrom = as.factor(chrom)) %>% 
#   # ggplot(aes(x = pos / 1000000, y = neg_log10_p_adj, group = chrom, col = chrom)) + 
#   ggplot(aes(x = pos / 1000000, y = q_value_neg_log10, group = chrom, col = chrom)) + 
#   geom_point() + 
#   geom_hline(aes(yintercept = neg_log10_fdr05, lty = "FDR 05%")) +
#   geom_hline(aes(yintercept = neg_log10_fdr10, lty = "FDR 10%")) +
#   facet_grid(trait + model ~ chrom, switch = "x", scales = "free", space = "free_x") +
#   scale_color_manual(values = set_names(rep(c("black", "grey75"), length.out = 7), seq(1, 7))) +
#   ylab("-log(q)") +
#   xlab("Position") +
#   labs(title = "Assocation Analysis", subtitle = "TP + VP") +
#   theme_bw() +
#   theme(
#     panel.spacing.x = unit(x = 0, units = "in"),
#     panel.border = element_blank()
#   )
# 
# save_file <- file.path(fig_dir, "gwas_pheno_fw_man_all.jpg")
# ggsave(filename = save_file, plot = g_man_all, width = 7, height = 12)
# 
# 
# g_man_tp <- gwas_pheno_fw_adj$pop_tp %>%
#   mutate(chrom = as.factor(chrom)) %>% 
#   # ggplot(aes(x = pos / 1000000, y = neg_log10_p_adj, group = chrom, col = chrom)) + 
#   ggplot(aes(x = pos / 1000000, y = q_value_neg_log10, group = chrom, col = chrom)) +
#   geom_point() + 
#   geom_hline(aes(yintercept = neg_log10_fdr05, lty = "FDR 05%")) +
#   geom_hline(aes(yintercept = neg_log10_fdr10, lty = "FDR 10%")) +
#   facet_grid(trait + model ~ chrom, switch = "x", scales = "free", space = "free_x") +
#   scale_color_manual(guide = FALSE, 
#                      values = set_names(rep(c("black", "grey75"), length.out = 7), seq(1, 7))) +
#   ylab("-log(q)") +
#   xlab("Position (Mbp)") +
#   labs(title = "Assocation Analysis", subtitle = "TP") +
#   theme_bw() +
#   theme(
#     panel.spacing.x = unit(x = 0, units = "in"),
#     panel.border = element_blank(),
#     axis.text.x = element_text(angle = 45, hjust = 1)
#   )
# 
# save_file <- file.path(fig_dir, "gwas_pheno_fw_man_tp.jpg")
# ggsave(filename = save_file, plot = g_man_tp, width = 7, height = 12)
# 
# 
# ## Only use the TP and only consider the G model
# g_man_tp <- gwas_pheno_fw_adj$pop_tp %>%
#   filter(model == "G") %>%
#   separate(trait, into = c("trait", "stability"), sep = "_") %>%
#   mutate(chrom = as.factor(chrom),
#          stability = if_else(stability == "b", "Type II", "Type III")) %>% 
#   # ggplot(aes(x = pos / 1000000, y = neg_log10_p_adj, group = chrom, col = chrom)) + 
#   ggplot(aes(x = pos / 1000000, y = q_value_neg_log10, group = chrom, col = chrom)) +
#   geom_point() + 
#   geom_hline(aes(yintercept = neg_log10_fdr05, lty = "FDR 05%")) +
#   geom_hline(aes(yintercept = neg_log10_fdr10, lty = "FDR 10%")) +
#   facet_grid(trait + stability ~ chrom, switch = "x", scales = "free", space = "free_x") +
#   scale_color_manual(guide = FALSE, 
#                      values = set_names(rep(c("black", "grey75"), length.out = 7), seq(1, 7))) +
#   scale_linetype_discrete(guide = FALSE) +
#   ylab("-log(q)") +
#   xlab("Position (Mbp)") +
#   labs(title = "Genomewide Assocation Analysis for Phenotypic Stability",
#        caption = "n = 183 lines used to calculate stability coefficients and n = 175 lines used\nfor association analysis. The bold line indicates the genomewide FDR threshold at 5%;\nthe dashed line at 10%.") +
#   theme_bw() +
#   theme(
#     panel.spacing.x = unit(x = 0, units = "in"),
#     panel.border = element_blank(),
#     axis.text.x = element_text(angle = 45, hjust = 1)
#   )
# 
# save_file <- file.path(fig_dir, "gwas_pheno_fw_man_tp_final.jpg")
# ggsave(filename = save_file, plot = g_man_tp, width = 10, height = 8)
# 
# 
# 
# ## Only use the TP and only consider the G model, plus only look at the slope from FW
# g_man_tp_typeii <- gwas_pheno_fw_adj$pop_tp %>%
#   filter(model == "G") %>%
#   separate(trait, into = c("trait", "stability"), sep = "_") %>%
#   mutate(chrom = as.factor(chrom),
#          stability = if_else(stability == "b", "Type II", "Type III")) %>% 
#   filter(stability == "Type II") %>%
#   ggplot(aes(x = pos / 1000000, y = q_value_neg_log10, group = chrom, col = chrom)) + 
#   geom_point() + 
#   geom_hline(aes(yintercept = neg_log10_fdr05, lty = "FDR 05%")) +
#   geom_hline(aes(yintercept = neg_log10_fdr10, lty = "FDR 10%")) +
#   facet_grid(trait ~ chrom, switch = "x", scales = "free", space = "free_x") +
#   scale_color_manual(guide = FALSE, 
#                      values = set_names(rep(c("black", "grey75"), length.out = 7), seq(1, 7))) +
#   scale_linetype_discrete(guide = FALSE) +
#   ylab("-log(q)") +
#   xlab("Position (Mbp)") +
#   labs(title = "Genomewide Assocation Analysis for Phenotypic Stability",
#        caption = "n = 183 lines used to calculate stability coefficients and n = 175 lines used\nfor association analysis. The bold line indicates the genomewide FDR threshold at 5%;\nthe dashed line at 10%.") +
#   theme_bw() +
#   theme(
#     panel.spacing.x = unit(x = 0, units = "in"),
#     panel.border = element_blank(),
#     axis.text.x = element_text(angle = 45, hjust = 1)
#   )
# 
# save_file <- file.path(fig_dir, "gwas_pheno_fw_man_tp_typeii.jpg")
# ggsave(filename = save_file, plot = g_man_tp_typeii, width = 9, height = 7, dpi = 1000)




```



